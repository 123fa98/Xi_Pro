local Library = loadstring(game:HttpGet("https://pastefy.app/niNg09Ax/raw"))()
local ThemeManager = loadstring(game:HttpGet("https://pastefy.app/UeecqM88/raw"))()
local SaveManager = loadstring(game:HttpGet("https://pastefy.app/7kpiyz2W/raw"))()
local Options = Library.Options
local Toggles = Library.Toggles
Library.ShowToggleFrameInKeybinds = true 
Library.ShowCustomCursor = true
Library.NotifySide = "Right"


local Window = Library:CreateWindow({
	Title = ' NOL | Forsaken',
	Footer = "XI Team",
    Icon = "rbxassetid://4483362748",
	Center = true,
	AutoShow = true,
	Resizable = true,
	ShowCustomCursor = true,
	NotifySide = "Right",
	TabPadding = 8,
	MenuFadeTime = 0
})

local Tabs = {
    new = Window:AddTab('公告', 'person-standing'),
	Main = Window:AddTab('主要功能','house'),
	Esp = Window:AddTab('绘制功能','eye'),
	zdg = Window:AddTab('格挡功能','user'),
	Sat = Window:AddTab('体力功能','zap'),
	zdx = Window:AddTab('电机功能','printer'),
	Aimbot = Window:AddTab('自瞄功能','crosshair'),
	tzq = Window:AddTab('通知提示','mails'),
	tfz = Window:AddTab('杀戮光环','skull'),
	lol = Window:AddTab('披萨功能','pizza'),
	Max = Window:AddTab('动作功能','earth'),
	ani = Window:AddTab('反效果功能','cpu'),
   ["UI Settings"] = Window:AddTab('界面调试', 'settings')
}

local _env = getgenv and getgenv() or {}
local _hrp = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")

local new = Tabs.new:AddLeftGroupbox('公告')
new:AddLabel("[+] 团队：XI团队")
new:AddLabel("[+] 团队脚本：XiPro，Nol，Ne Hub，Rb中心付费版，霖溺")
new:AddLabel("[+] 开发者：宇星辰")


local MainTabbox = Tabs.Main:AddRightTabbox()
local Lighting = MainTabbox:AddTab("亮度")

Lighting:AddSlider("B",{
    Text = "正常",
    Min = 0,
    Default = 0,
    Max = 3,
    Rounding = 1,
    Compact = true,
    Callback = function(v)
        _env.Brightness = v
    end
})

Lighting:AddToggle("无阴影",{
    Text = "无阴影",
    Default = false,
    Callback = function(v)
        _env.GlobalShadows = v
    end
})

Lighting:AddToggle("除雾",{
    Text = "除雾",
    Default = false,
    Callback = function(v)
        _env.NoFog = v
    end
})

Lighting:AddDivider()

Lighting:AddToggle("启用功能",{
    Text = "启用功能",
    Default = false,
    Callback = function(v)
        _env.Fullbright = v
        game:GetService("RunService").RenderStepped:Connect(function()
            if not game.Lighting:GetAttribute("FogStart") then 
                game.Lighting:SetAttribute("FogStart", game.Lighting.FogStart) 
            end
            if not game.Lighting:GetAttribute("FogEnd") then 
                game.Lighting:SetAttribute("FogEnd", game.Lighting.FogEnd) 
            end
            game.Lighting.FogStart = _env.NoFog and 0 or game.Lighting:GetAttribute("FogStart")
            game.Lighting.FogEnd = _env.NoFog and math.huge or game.Lighting:GetAttribute("FogEnd")
            
            local fog = game.Lighting:FindFirstChildOfClass("Atmosphere")
            if fog then
                if not fog:GetAttribute("Density") then 
                    fog:SetAttribute("Density", fog.Density) 
                end
                fog.Density = _env.NoFog and 0 or fog:GetAttribute("Density")
            end
            
            if _env.Fullbright then
                game.Lighting.OutdoorAmbient = Color3.new(1,1,1)
                game.Lighting.Brightness = _env.Brightness or 0
                game.Lighting.GlobalShadows = not _env.GlobalShadows
            else
                game.Lighting.OutdoorAmbient = Color3.fromRGB(55,55,55)
                game.Lighting.Brightness = 0
                game.Lighting.GlobalShadows = true
            end
        end)
    end
    
})

local ZZ = Tabs.Main:AddLeftGroupbox('自动狂暴节奏')

-- Persistent storage for range
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local savedRange = lp:FindFirstChild("RagingPaceRange")
if not savedRange then
    savedRange = Instance.new("NumberValue")
    savedRange.Name = "RagingPaceRange"
    savedRange.Value = 19 -- default range
    savedRange.Parent = lp
end

-- Add range slider at the beginning
ZZ:AddSlider("RagingPaceRange", {
    Text = "狂暴节奏范围",
    Default = savedRange.Value,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Compact = true,
    Callback = function(value)
        savedRange.Value = value
    end
})

-- Main toggle
ZZ:AddToggle("RagingPace", {
    Text = "自动狂暴节奏",
    Default = false,
    Callback = function(enabled)
        local threadId = tostring(math.random(1, 99999))
        _G.RagingPaceThreadId = threadId
        
        local function shouldContinue()
            return _G.RagingPaceThreadId == threadId and enabled
        end
        
        -- Local variables
        local RunService = game:GetService("RunService")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RANGE = savedRange.Value
        local SPAM_DURATION = 3
        local COOLDOWN_TIME = 5
        local activeCooldowns = {}

        -- Animation ID List
        local animsToDetect = {
            ["116618003477002"] = true,
            ["119462383658044"] = true,
            ["131696603025265"] = true,
            ["121255898612475"] = true,
            ["133491532453922"] = true,
            ["103601716322988"] = true,
            ["86371356500204"] = true,
            ["72722244508749"] = true,
            ["87259391926321"] = true,
            ["96959123077498"] = true,
        }

        local function fireRagingPace()
            local args = { "UseActorAbility", "RagingPace" }
            ReplicatedStorage:WaitForChild("Modules")
                :WaitForChild("Network")
                :WaitForChild("RemoteEvent")
                :FireServer(unpack(args))
        end

        local function isAnimationMatching(anim)
            local id = tostring(anim.Animation and anim.Animation.AnimationId or "")
            local numId = id:match("%d+")
            return animsToDetect[numId] or false
        end

        local function runDetection()
            local connection
            connection = RunService.Heartbeat:Connect(function()
                if not shouldContinue() then
                    connection:Disconnect()
                    return
                end
                
                for _, player in ipairs(Players:GetPlayers()) do
                    if not shouldContinue() then break end
                    
                    if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local targetHRP = player.Character.HumanoidRootPart
                        local myChar = lp.Character
                        if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                            local dist = (targetHRP.Position - myChar.HumanoidRootPart.Position).Magnitude
                            if dist <= RANGE and (not activeCooldowns[player] or tick() - activeCooldowns[player] >= COOLDOWN_TIME) then
                                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
                                        if not shouldContinue() then break end
                                        
                                        if isAnimationMatching(track) then
                                            activeCooldowns[player] = tick()
                                            task.spawn(function()
                                                local startTime = tick()
                                                while shouldContinue() and tick() - startTime < SPAM_DURATION do
                                                    fireRagingPace()
                                                    task.wait(0.05)
                                                end
                                            end)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
            
            return connection
        end

        if enabled then
            -- Cancel previous thread
            if _G.RagingPaceConnection then
                _G.RagingPaceConnection:Disconnect()
                _G.RagingPaceConnection = nil
            end
            
            -- Start new detection
            _G.RagingPaceConnection = runDetection()
        else
            -- Close detection
            if _G.RagingPaceConnection then
                _G.RagingPaceConnection:Disconnect()
                _G.RagingPaceConnection = nil
            end
        end
    end
})







local ZZ = Tabs.Main:AddLeftGroupbox('自动使用404错误[约翰·杜]')

ZZ:AddToggle("AntiAnimations", {
    Text = "自动404错误",
    Default = false,
    Callback = function(enabled)
        local threadId = tostring(math.random(1, 99999))
        _G.AntiAnimThreadId = threadId
        
        local function shouldContinue()
            return _G.AntiAnimThreadId == threadId and enabled
        end
        
        -- 原有变量
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local lp = Players.LocalPlayer
        local RANGE = 19
        local SPAM_DURATION = 3
        local COOLDOWN_TIME = 5
        local activeCooldowns = {}

        local animsToDetect = {
            ["116618003477002"] = true,
            ["119462383658044"] = true,
            ["131696603025265"] = true,
            ["121255898612475"] = true,
            ["133491532453922"] = true,
            ["103601716322988"] = true,
            ["86371356500204"] = true,
            ["72722244508749"] = false,
            ["87259391926321"] = true,
            ["96959123077498"] = false,
            ["86709774283672"] = true,
            ["77448521277146"] = true,
        }

        local function fire404Error()
            local args = { "UseActorAbility", "404Error" }
            ReplicatedStorage:WaitForChild("Modules")
                :WaitForChild("Network")
                :WaitForChild("RemoteEvent")
                :FireServer(unpack(args))
        end

        local function isAnimationMatching(anim)
            local id = tostring(anim.Animation and anim.Animation.AnimationId or "")
            local numId = id:match("%d+")
            return animsToDetect[numId] or false
        end

        local function runDetection()
            local connection
            connection = RunService.Heartbeat:Connect(function()
                if not shouldContinue() then
                    connection:Disconnect()
                    return
                end
                
                for _, player in ipairs(Players:GetPlayers()) do
                    if not shouldContinue() then break end
                    
                    if player ~= lp and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local targetHRP = player.Character.HumanoidRootPart
                        local myChar = lp.Character
                        if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                            local dist = (targetHRP.Position - myChar.HumanoidRootPart.Position).Magnitude
                            if dist <= RANGE and (not activeCooldowns[player] or tick() - activeCooldowns[player] >= COOLDOWN_TIME) then
                                local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                                if humanoid then
                                    for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
                                        if not shouldContinue() then break end
                                        
                                        if isAnimationMatching(track) then
                                            activeCooldowns[player] = tick()
                                            task.spawn(function()
                                                local startTime = tick()
                                                while shouldContinue() and tick() - startTime < SPAM_DURATION do
                                                    fire404Error()
                                                    task.wait(0.05)
                                                end
                                            end)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
            
            return connection
        end

        if enabled then
            -- 取消之前的线程
            if _G.AntiAnimConnection then
                _G.AntiAnimConnection:Disconnect()
                _G.AntiAnimConnection = nil
            end
            
            -- 启动新的检测
            _G.AntiAnimConnection = runDetection()
        else
            -- 关闭检测
            if _G.AntiAnimConnection then
                _G.AntiAnimConnection:Disconnect()
                _G.AntiAnimConnection = nil
            end
        end
    end
})






local Player = Tabs.Max:AddLeftGroupbox("动画功能")



-- Silly Billy 动作按钮
Player:AddToggle("SillyBillyToggle", {
    Text = "Silly Billy",
    Default = false,
    Tooltip = "播放Silly Billy表情动作",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://107464355830477"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://77601084987544"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = false
            sound:Play()
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
                
                for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                    local asset = char:FindFirstChild(assetName)
                    if asset then asset:Destroy() end
                end
            end)
        else
            -- 关闭状态
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                local asset = char:FindFirstChild(assetName)
                if asset then asset:Destroy() end
            end
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://107464355830477" then
                    track:Stop()
                end
            end
        end
    end
})

-- Silly of it 动作按钮
Player:AddToggle("SillyOfItToggle", {
    Text = "Silly of it",
    Default = false,
    Tooltip = "播放Silly of it表情动作",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态（完整实现，与原始函数相同）
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://107464355830477"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://120176009143091"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = false
            sound:Play()
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
                
                for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                    local asset = char:FindFirstChild(assetName)
                    if asset then asset:Destroy() end
                end
            end)
        else
            -- 关闭状态（完整实现）
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                local asset = char:FindFirstChild(assetName)
                if asset then asset:Destroy() end
            end
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://107464355830477" then
                    track:Stop()
                end
            end
        end
    end
})

-- Subterfuge 动作按钮
Player:AddToggle("SubterfugeToggle", {
    Text = "Subterfuge",
    Default = false,
    Tooltip = "播放Subterfuge表情动作",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态（完整实现）
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://87482480949358"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://132297506693854"
            sound.Parent = rootPart
            sound.Volume = 2
            sound.Looped = false
            sound:Play()
            
            local args = {
                [1] = "PlayEmote",
                [2] = "Animations",
                [3] = "_Subterfuge"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
            end)
        else
            -- 关闭状态（完整实现）
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://87482480949358" then
                    track:Stop()
                end
            end
        end
    end
})

-- Aw Shucks 动作按钮
Player:AddToggle("AwShucksToggle", {
    Text = "Aw Shucks",
    Default = false,
    Tooltip = "播放Aw Shucks表情动作",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态（完整实现）
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://74238051754912"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://123236721947419"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = false
            sound:Play()
            
            local args = {
                [1] = "PlayEmote",
                [2] = "Animations",
                [3] = "Shucks"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
            end)
        else
            -- 关闭状态（完整实现）
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://74238051754912" then
                    track:Stop()
                end
            end
        end
    end
})

-- Miss The Quiet 动作按钮
Player:AddToggle("MissTheQuietToggle", {
    Text = "Miss The Quiet",
    Default = false,
    Tooltip = "播放Miss The Quiet表情动作",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态（完整实现）
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://100986631322204"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://131936418953291"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = false
            sound:Play()
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
                
                for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                    local asset = char:FindFirstChild(assetName)
                    if asset then asset:Destroy() end
                end
            end)
        else
            -- 关闭状态（完整实现）
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            for _, assetName in ipairs({"EmoteHatAsset", "EmoteLighting", "PlayerEmoteHand"}) do
                local asset = char:FindFirstChild(assetName)
                if asset then asset:Destroy() end
            end
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://100986631322204" then
                    track:Stop()
                end
            end
        end
    end
})



Player:AddToggle('MyToggle', {
    Text = '강남풍 [Jiang nan]',
    Default = false,
    Callback = function(state)
    action(state)
end
})


-- VIP动作（新音频）按钮
Player:AddToggle("VIPToggleNew", {
    Text = "VIP (New)",
    Default = false,
    Tooltip = "VIP（New）",
    Callback = function(state)
        local char = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")
        local rootPart = char:WaitForChild("HumanoidRootPart")
        
        if state then
            -- 激活状态（完整实现）
            humanoid.PlatformStand = true
            humanoid.JumpPower = 0
            
            local bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
            bodyVelocity.Velocity = Vector3.zero
            bodyVelocity.Parent = rootPart
            
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://138019937280193"
            local animationTrack = humanoid:LoadAnimation(animation)
            animationTrack:Play()
            
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://109474987384441"
            sound.Parent = rootPart
            sound.Volume = 0.5
            sound.Looped = true
            sound:Play()
            
            local effect = game:GetService("ReplicatedStorage").Assets.Emotes.HakariDance.HakariBeamEffect:Clone()
            effect.Name = "PlayerEmoteVFX"
            effect.CFrame = char.PrimaryPart.CFrame * CFrame.new(0, -1, -0.3)
            effect.WeldConstraint.Part0 = char.PrimaryPart
            effect.WeldConstraint.Part1 = effect
            effect.Parent = char
            effect.CanCollide = false
            
            local args = {
                [1] = "PlayEmote",
                [2] = "Animations",
                [3] = "HakariDance"
            }
            game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
            
            animationTrack.Stopped:Connect(function()
                humanoid.PlatformStand = false
                if bodyVelocity and bodyVelocity.Parent then
                    bodyVelocity:Destroy()
                end
            end)
        else
            -- 关闭状态（完整实现）
            humanoid.PlatformStand = false
            humanoid.JumpPower = 0
            
            local bodyVelocity = rootPart:FindFirstChildOfClass("BodyVelocity")
            if bodyVelocity then bodyVelocity:Destroy() end
            
            local sound = rootPart:FindFirstChildOfClass("Sound")
            if sound then
                sound:Stop()
                sound:Destroy()
            end
            
            local effect = char:FindFirstChild("PlayerEmoteVFX")
            if effect then effect:Destroy() end
            
            for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                if track.Animation.AnimationId == "rbxassetid://138019937280193" then
                    track:Stop()
                end
            end
        end
    end
})


local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- 创建一个体力功能组
local MVP = Tabs.Sat:AddLeftGroupbox("体力功能")

-- 体力系统设置
local StaminaSettings = {
    MaxStamina = 100,      -- 最大体力值
    StaminaGain = 25,      -- 体力恢复速度
    StaminaLoss = 10,      -- 体力消耗速度
    SprintSpeed = 28,      -- 奔跑速度
    InfiniteGain = 9999    -- 无限体力恢复速度
}

-- 体力控制开关
local SettingToggles = {
    MaxStamina = true,
    StaminaGain = true,
    StaminaLoss = true,
    SprintSpeed = true
}

-- 获取游戏体力模块
local SprintingModule = ReplicatedStorage:WaitForChild("Systems"):WaitForChild("Character"):WaitForChild("Game"):WaitForChild("Sprinting")
local GetModule = function() return require(SprintingModule) end

-- 实时更新体力设置
task.spawn(function()
    while true do
        local m = GetModule()
        for key, value in pairs(StaminaSettings) do
            if SettingToggles[key] then
                m[key] = value
            end
        end
        task.wait(0.5)
    end
end)

-- 无限功能
local bai = {Spr = false}
local connection

MVP:AddToggle('MyToggle', {
    Text = '无限体力',
    Default = false,
    Tooltip = 'huh?',
    Callback = function(state)
        bai.Spr = state
        local Sprinting = GetModule()

        if state then
            Sprinting.StaminaLoss = 0
            Sprinting.StaminaGain = StaminaSettings.InfiniteGain or 9999

            if connection then connection:Disconnect() end
            connection = RunService.Heartbeat:Connect(function()
                if not bai.Spr then return end
                Sprinting.StaminaLoss = 0
                Sprinting.StaminaGain = StaminaSettings.InfiniteGain or 9999
            end)
        else
            Sprinting.StaminaLoss = StaminaSettings.StaminaLoss or 10
            Sprinting.StaminaGain = StaminaSettings.StaminaGain or 25

            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
})

MVP:AddToggle('MaxStaminaToggle', {
    Text = '启用体力上限调整',
    Default = true,
    Callback = function(Value)
        SettingToggles.MaxStamina = Value
    end
})

MVP:AddToggle('StaminaGainToggle', {
    Text = '启用体力恢复调整',
    Default = true,
    Callback = function(Value)
        SettingToggles.StaminaGain = Value
    end
})

MVP:AddToggle('StaminaLossToggle', {
    Text = '启用体力消耗调整',
    Default = true,
    Callback = function(Value)
        SettingToggles.StaminaLoss = Value
    end
})

MVP:AddToggle('SprintSpeedToggle', {
    Text = '启用奔跑速度调整',
    Default = true,
    Callback = function(Value)
        SettingToggles.SprintSpeed = Value
    end
})







local MVP = Tabs.Sat:AddRightGroupbox("调试")

MVP:AddSlider('InfStaminaGainSlider', {
    Text = '无限体力恢复速度',
    Default = 9999,
    Min = 0,
    Max = 10000,
    Rounding = 0,
    Callback = function(Value)
        StaminaSettings.InfiniteGain = Value
    end
})

MVP:AddSlider('MySlider1', {
    Text = '体力上限',
    Default = 100,
    Min = 0,
    Max = 9999,
    Rounding = 0,
    Callback = function(Value)
        StaminaSettings.MaxStamina = Value
    end
})

MVP:AddSlider('MySlider2', {
    Text = '体力恢复倍率',
    Default = 25,
    Min = 0,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        StaminaSettings.StaminaGain = Value
    end
})

MVP:AddSlider('MySlider3', {
    Text = '体力消耗倍率',
    Default = 10,
    Min = 0,
    Max = 800,
    Rounding = 0,
    Callback = function(Value)
        StaminaSettings.StaminaLoss = Value
    end
})

MVP:AddSlider('MySlider4', {
    Text = '冲刺速度',
    Default = 28,
    Min = 0,
    Max = 200,
    Rounding = 0,
    Callback = function(Value)
        StaminaSettings.SprintSpeed = Value
    end
})

local ZZ = Tabs.zdg:AddLeftGroupbox('拦截 Guest 1337')
pcall(function()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    
    local config_114514 = {
        Enabled = false,
        BaseDistance = 16,
        ScanInterval = 0.005,
        BlockCooldown = 0.15,
        MoveCompBase = 1.5,
        MoveCompFactor = 0.25,
        SpeedThreshold = 8,
        PredictBase = 4,
        PredictMax = 8,
        PredictFactor = 0.22,
        TargetAngle = 50,
        MinAttackSpeed = 12,
        ShowVisualization = false,
        EnablePrediction = false,
        TargetSoundIds = {
            "102228729296384", "140242176732868", "112809109188560", "136323728355613",
            "115026634746636", "84116622032112", "108907358619313", "127793641088496",
            "86174610237192", "95079963655241", "101199185291628", "119942598489800",
            "84307400688050", "113037804008732", "105200830849301", "75330693422988",
            "82221759983649", "81702359653578", "108610718831698", "112395455254818",
            "109431876587852", "109348678063422", "85853080745515", "12222216"
        }
    }
    
    local soundLookup = {}
    for _, id in ipairs(config_114514.TargetSoundIds) do
        soundLookup[id] = true
        soundLookup["rbxassetid://" .. id] = true
    end
    
    local LocalPlayer = Players.LocalPlayer
    local lastBlockTime = 0
    local combatConnection = nil
    local lastScanTime = 0
    local visualizationParts = {}
    local soundCache = {}
    local lastSoundCheck = 0
    
    local function CreateVisualization()
        if not LocalPlayer.Character then return end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        
        for _, part in ipairs(visualizationParts) do
            part:Destroy()
        end
        visualizationParts = {}
        
        local center = rootPart.Position
        local distance = config_114514.BaseDistance
        local angle = math.rad(config_114514.TargetAngle)
        local segments = 36
        
        local basePart = Instance.new("Part")
        basePart.Size = Vector3.new(0.1, 0.1, 0.1)
        basePart.Position = center + Vector3.new(0, 0.1, 0)
        basePart.Anchored = true
        basePart.CanCollide = false
        basePart.Transparency = 1
        basePart.Parent = workspace
        table.insert(visualizationParts, basePart)
        
        for i = 1, segments do
            local part = Instance.new("Part")
            part.Size = Vector3.new(0.5, 0.1, 0.5)
            part.BrickColor = BrickColor.new("Bright green")
            part.Material = Enum.Material.Neon
            part.Transparency = 0.7
            part.Anchored = true
            part.CanCollide = false
            part.Parent = workspace
            table.insert(visualizationParts, part)
        end
        
        local function UpdateVisualization()
            if not config_114514.ShowVisualization then return end
            if not LocalPlayer.Character then return end
            local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not root then return end
            
            local center = root.Position + Vector3.new(0, 0.1, 0)
            local lookVector = root.CFrame.LookVector
            local distance = config_114514.BaseDistance
            local angle = math.rad(config_114514.TargetAngle)
            
            basePart.Position = center
            
            for i = 1, #visualizationParts - 1 do
                local part = visualizationParts[i + 1]
                local segmentAngle = (i - 1) * (2 * angle) / (#visualizationParts - 2) - angle
                local rotCFrame = CFrame.fromAxisAngle(Vector3.new(0, 1, 0), segmentAngle)
                local dir = rotCFrame:VectorToWorldSpace(lookVector)
                local pos = center + dir * distance
                part.Position = pos
                part.Size = Vector3.new(0.5, 0.1, 0.5)
            end
        end
        
        local visConnection
        visConnection = RunService.Heartbeat:Connect(function()
            if not config_114514.ShowVisualization then
                for _, part in ipairs(visualizationParts) do
                    part:Destroy()
                end
                visualizationParts = {}
                visConnection:Disconnect()
                return
            end
            pcall(UpdateVisualization)
        end)
    end
    
    local function HasTargetSound(character)
        if not character then return false end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return false end
        
        local currentTime = os.clock()
        if currentTime - lastSoundCheck < 0.001 then
            return soundCache[character] or false
        end
        lastSoundCheck = currentTime
        
        local found = false
        for _, child in ipairs(rootPart:GetChildren()) do
            if child:IsA("Sound") then
                local soundId = tostring(child.SoundId)
                local numericId = string.match(soundId, "(%d+)$")
                if numericId and soundLookup[numericId] then
                    found = true
                    break
                end
            end
        end
        
        soundCache[character] = found
        return found
    end
    
    local function GetMoveCompensation()
        if not LocalPlayer.Character then return 0 end
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not rootPart then return 0 end
        
        local velocity = rootPart.Velocity
        local speed = math.sqrt(velocity.X^2 + velocity.Y^2 + velocity.Z^2)
        return config_114514.MoveCompBase + (speed * config_114514.MoveCompFactor)
    end
    
    local function GetTotalDetectionRange(killer)
        local base = config_114514.BaseDistance
        local moveBonus = GetMoveCompensation()
        local predict = 0
        
        if config_114514.EnablePrediction and killer and killer:FindFirstChild("HumanoidRootPart") then
            local killerVel = killer.HumanoidRootPart.Velocity
            local killerSpeed = math.sqrt(killerVel.X^2 + killerVel.Y^2 + killerVel.Z^2)
            
            if killerSpeed > config_114514.SpeedThreshold then
                predict = math.min(
                    config_114514.PredictMax, 
                    config_114514.PredictBase + (killerSpeed * config_114514.PredictFactor)
                )
            end
        end
        
        return base + moveBonus + predict
    end
    
    local function IsTargetingMe(killer)
        local myCharacter = LocalPlayer.Character
        if not myCharacter then return false end
        
        local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
        local killerRoot = killer and killer:FindFirstChild("HumanoidRootPart")
        if not myRoot or not killerRoot then return false end
        
        local directionToMe = (myRoot.Position - killerRoot.Position).Unit
        local killerLook = killerRoot.CFrame.LookVector
        
        local dot = directionToMe:Dot(killerLook)
        local angle = math.deg(math.acos(math.clamp(dot, -1, 1)))
        
        return angle <= config_114514.TargetAngle
    end
    
    local function GetThreateningKillers()
        local killers = {}
        local killersFolder = workspace:FindFirstChild("Killers") or (workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers"))
        if not killersFolder then return killers end
        
        local myCharacter = LocalPlayer.Character
        if not myCharacter then return killers end
        
        local myRoot = myCharacter:FindFirstChild("HumanoidRootPart")
        if not myRoot then return killers end
        
        for _, killer in ipairs(killersFolder:GetChildren()) do
            if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
                local killerRoot = killer.HumanoidRootPart
                local distance = (myRoot.Position - killerRoot.Position).Magnitude
                local detectionRange = GetTotalDetectionRange(killer)
                
                if distance <= detectionRange and HasTargetSound(killer) and IsTargetingMe(killer) then
                    table.insert(killers, killer)
                end
            end
        end
        
        return killers
    end
    
    local function GetAdjustedCooldown()
        return config_114514.BlockCooldown
    end
    
    local function PerformBlock()
        local now = os.clock()
        if now - lastBlockTime >= GetAdjustedCooldown() then
            pcall(function()
                local args = {
                    "UseActorAbility",
                    {
                        buffer.fromstring("\"Block\"")
                    }
                }
                game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
                lastBlockTime = now
            end)
        end
    end
    
    
    local function CombatLoop()
        local currentTime = os.clock()
        if currentTime - lastScanTime >= config_114514.ScanInterval then
            lastScanTime = currentTime
            local killers = GetThreateningKillers()
            if #killers > 0 then
                PerformBlock()
            end
        end
    end
    
    ZZ:AddToggle("AutoBlockToggle", {
        Text = "自动阻挡",
        Default = false,
        Callback = function(enabled)
            config_114514.Enabled = enabled
            if enabled then
                if combatConnection then
                    combatConnection:Disconnect()
                end
                combatConnection = RunService.Stepped:Connect(function()
                    pcall(CombatLoop)
                end)
            elseif combatConnection then
                combatConnection:Disconnect()
                combatConnection = nil
            end
        end
    })
    
    ZZ:AddSlider("BaseDistance", {
        Text = "距离",
        Default = 16,
        Min = 5,
        Max = 30,
        Rounding = 1,
        Callback = function(value)
            config_114514.BaseDistance = value
        end
    })
    
    ZZ:AddSlider("TargetAngleSlider", {
        Text = "角度",
        Default = 70,
        Min = 10,
        Max = 180,
        Rounding = 1,
        Callback = function(value)
            config_114514.TargetAngle = value
        end
    })
    
    ZZ:AddToggle("VisualizationToggle", {
        Text = "可视化",
        Default = false,
        Callback = function(enabled)
            config_114514.ShowVisualization = enabled
            if enabled then
                CreateVisualization()
            else
                for _, part in ipairs(visualizationParts) do
                    part:Destroy()
                end
                visualizationParts = {}
            end
        end
    })
    
    LocalPlayer.CharacterAdded:Connect(function()
        if config_114514.Enabled and combatConnection then
            combatConnection:Disconnect()
            combatConnection = RunService.Stepped:Connect(CombatLoop)
        end
        if config_114514.ShowVisualization then
            CreateVisualization()
        end
    end)
end)

local ZZ2 = Tabs.zdg:AddRightGroupbox('预测')

ZZ2:AddToggle("PredictionToggle", {
    Text = "预测已启用",
    Default = false,
    Callback = function(enabled)
        config_114514.EnablePrediction = enabled
    end
})

ZZ2:AddSlider("PredictBaseSlider", {
    Text = "预测基础",
    Default = 4,
    Min = 0,
    Max = 10,
    Rounding = 1,
    Callback = function(value)
        config_114514.PredictBase = value
    end
})

ZZ2:AddSlider("PredictFactorSlider", {
    Text = "预测系数",
    Default = 0.22,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(value)
        config_114514.PredictFactor = value
    end
})

ZZ2:AddSlider("PredictMaxSlider", {
    Text = "最大预测距离",
    Default = 8,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Callback = function(value)
        config_114514.PredictMax = value
    end
})

ZZ2:AddSlider("SpeedThresholdSlider", {
    Text = "预测速度",
    Default = 8,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Callback = function(value)
        config_114514.SpeedThreshold = value
    end
})





local NOL = Tabs.zdg:AddRightGroupbox('自动出拳')

NOL:AddToggle("AutoPunch", {
    Text = "自动出拳",
    Default = false,
    Callback = function(Value)
        -- 在回调外部定义变量，保持状态
        if not _G.AutoPunchVars then
            _G.AutoPunchVars = {
                ReplicatedStorage = game:GetService("ReplicatedStorage"),
                remoteEvent = nil,
                isRunning = false,
                connection = nil
            }
        end
        
        local vars = _G.AutoPunchVars
        
        -- 安全获取 RemoteEvent
        local function getRemoteEvent()
            local success, result = pcall(function()
                return vars.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
            end)
            
            if not success or not result then
                warn("无法找到 RemoteEvent！请检查路径：ReplicatedStorage.Modules.Network.RemoteEvent")
                return nil
            end
            return result
        end
        
        -- 开始自动出拳
        local function startAutoPunch()
            if vars.isRunning then return end
            vars.isRunning = true
            
            -- 如果还没有 RemoteEvent，尝试获取
            if not vars.remoteEvent then
                vars.remoteEvent = getRemoteEvent()
                if not vars.remoteEvent then
                    warn("RemoteEvent 未初始化，无法发送事件。")
                    vars.isRunning = false
                    return
                end
            end
            
            -- 创建循环
            vars.connection = task.spawn(function()
                while vars.isRunning and Value do  -- 同时检查开关状态
                    local args = {
                        [1] = "UseActorAbility",
                        [2] = "Punch"
                    }
                    vars.remoteEvent:FireServer(unpack(args))
                    task.wait(0.5)  -- 每 0.5 秒出一次拳
                end
                vars.isRunning = false
            end)
        end
        
        -- 停止自动出拳
        local function stopAutoPunch()
            if not vars.isRunning then return end
            vars.isRunning = false
            
            -- 取消循环
            if vars.connection then
                task.cancel(vars.connection)
                vars.connection = nil
            end
        end
        
        -- 根据开关状态执行
        if Value then
            startAutoPunch()
        else
            stopAutoPunch()
        end
    end
})

--------------------------------------------------
-- 发电机维修
--------------------------------------------------
local Generator = Tabs.zdx:AddLeftGroupbox("[维修发电机]")

Generator:AddDropdown('FixMode', {
    Values = {'危险', '安全', '自定义'},
    Default = 2,
    Multi = false,
    Text = '维修模式',
    Searchable = false,
    Callback = function(v)
        _G.FixMode = v
        if v == "危险" then
            Generator:SetValue("RepairSpeed", 3)
        elseif v == "安全" then
            Generator:SetValue("RepairSpeed", 5)
        end
    end
})

Generator:AddSlider("RepairSpeed", {
    Text = "维修耗时（秒）",
    Default = 4,
    Min = 1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        _G.CustomSpeed = v
    end
})

Generator:AddToggle("AutoGenerator", {
    Text = "自动维修发电机",
    Default = false,
    Callback = function(v)
        _G.AutoGen = v
        task.spawn(function()
            while _G.AutoGen do
                if game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("PuzzleUI") then
                    local delayTime = _G.CustomSpeed or 3
                    
                    if _G.FixMode == "危险" then
                        delayTime = 2.5
                    elseif _G.FixMode == "安全" then
                        delayTime = 5
                    end
                    
                    wait(delayTime)
                    
                    for _, v in ipairs(workspace["Map"]["Ingame"]["Map"]:GetChildren()) do
                        if v.Name == "Generator" then
                            v["Remotes"]["RE"]:FireServer()
                        end
                    end
                end
                wait()
            end
        end)
    end
})

local KillerSurvival = Tabs.zdx:AddRightGroupbox('瞬移修发电机【危险】')

KillerSurvival:AddButton({
    Text = '传送到发电机',
    Func = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        
        local generators = workspace.Map.Ingame.Map:GetChildren()
        for _, generator in ipairs(generators) do
            if generator.Name == "Generator" and 
               generator:FindFirstChild("Progress") and 
               generator.Progress.Value < 100 then
                
                local generatorPart = generator:FindFirstChild("Main") or  
                                     generator:FindFirstChild("Model") or
                                     generator:FindFirstChild("Base")
                
                if generatorPart then
                    character.HumanoidRootPart.CFrame = generatorPart.CFrame + Vector3.new(0, 3, 0)
                    return  
                end
            end
        end
        warn("没有找到可修理的发电机")
    end
})

KillerSurvival:AddToggle("AutoFix", {
    Text = "自动发电机速刷",
    Default = false,
    Callback = function(enabled)
        local threadId = tostring(math.random(1, 99999))
        _G.AutoFixThreadId = threadId
        
        local function shouldContinue()
            return _G.AutoFixThreadId == threadId and enabled
        end
        
        local function allGeneratorsFixed()
            for _, v in ipairs(workspace.Map.Ingame.Map:GetChildren()) do
                if v.Name == "Generator" and v:FindFirstChild("Progress") and v.Progress.Value < 100 then
                    return false
                end
            end
            return true
        end
        
        local function fastInteract(generator, action)
            local args = {[1] = action}
            pcall(function()
                generator.Remotes.RF:InvokeServer(unpack(args))
            end)
        end

        local function fastRepair(generator)
            pcall(function()
                generator.Remotes.RE:FireServer()
            end)
        end
        
        local function runGenerator()
            while shouldContinue() and not allGeneratorsFixed() do
                local generators = {}
                for _, v in ipairs(workspace.Map.Ingame.Map:GetChildren()) do
                    if v.Name == "Generator" and v:FindFirstChild("Progress") and v.Progress.Value < 100 then
                        table.insert(generators, v)
                    end
                end
                
                for _, generator in ipairs(generators) do
                    if not shouldContinue() then break end
                    
                    local char = game.Players.LocalPlayer.Character
                    if char and char:FindFirstChild("HumanoidRootPart") then
                        -- 传送(0.5秒)
                        local startTP = tick()
                        
                        -- 寻找传送点
                        local bestPos, minDist = nil, math.huge
                        if generator:FindFirstChild("Positions") then
                            for _, pos in ipairs(generator.Positions:GetChildren()) do
                                local dist = (char.HumanoidRootPart.Position - pos.Position).Magnitude
                                if dist < minDist then
                                    bestPos = pos
                                    minDist = dist
                                end
                            end
                            
                            if bestPos then
                                char.HumanoidRootPart.CFrame = bestPos.CFrame * CFrame.new(0, 0, -1.2) -- 传送位置
                            end
                        end
                        
                        -- 精确控制传送时间
                        local elapsed = tick() - startTP
                        if elapsed < 0.17 then
                            task.wait(0.17 - elapsed)
                        end
                        
                        -- 交互流程
                        fastInteract(generator, "enter")
                        task.wait(0.00001) -- 最小必要等待
                        
                        -- 单次修理
                        fastRepair(generator)
                        task.wait(0.1) -- 修理确认时间
                        
                        -- 立即离开
                        fastInteract(generator, "leave")
                        
                        -- 循环等待
                        task.wait(0.000000000000001) -- 电机间间隔
                    end
                end
                
                if shouldContinue() then
                    task.wait(0.000000000000000001) -- 循环缓冲
                end
            end
        end

        if enabled then
            if _G.AutoFixThread then
                _G.AutoFixThreadId = tostring(math.random(1, 99999))
                task.cancel(_G.AutoFixThread)
            end
            _G.AutoFixThread = task.spawn(runGenerator)
        else
            _G.AutoFixThreadId = tostring(math.random(1, 99999))
            if _G.AutoFixThread then
                task.cancel(_G.AutoFixThread)
                _G.AutoFixThread = nil
            end
        end
    end
})



local ZZ = Tabs.zdx:AddRightGroupbox('切换服务器')

ZZ:AddButton({
    Text = "切换服务器", 
    Func = function()
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        local HttpService = game:GetService("HttpService")
        
        local requestFunc = http_request or syn.request or request
        if not requestFunc then return end
            
        local url = "https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"
        local response = requestFunc({Url = url, Method = "GET"})
        
        if response.StatusCode == 200 then
            local data = HttpService:JSONDecode(response.Body)
            if data and data.data and #data.data > 0 then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, data.data[math.random(1, #data.data)].id, Players.LocalPlayer)
            end
        end
    end
})






local Visual = Tabs.Esp:AddRightGroupbox("2D 方框")

Visual:AddToggle("SE", {
    Text = "幸存者方框",
    Default = false,
    Callback = function(v)
        if v then
            local a = workspace:WaitForChild("Players")
            local c = a:WaitForChild("Survivors")
            local d = game:GetService("RunService")
            local e = game:GetService("Players").LocalPlayer
            
            local function f(g, h)
                if not g:IsA("Model") then return end
                if g == e.Character then return end
                local i = g:FindFirstChild("HumanoidRootPart")
                if not i then return end
                if i:FindFirstChild("playeresp") then return end
                
                local j = Instance.new("BillboardGui")
                j.Name = "playeresp"
                j.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                j.Active = true
                j.AlwaysOnTop = true
                j.LightInfluence = 1.000
                j.Size = UDim2.new(3, 0, 5, 0)
                j.Adornee = i
                j.Parent = i
                
                local k = Instance.new("Frame")
                k.Name = "playershow"
                k.BackgroundColor3 = Color3.fromRGB(255, 25, 25)
                k.BackgroundTransparency = 1
                k.Size = UDim2.new(1, 0, 1, 0)
                k.Parent = j
                
                local l = Instance.new("UIStroke")
                l.Color = h
                l.Thickness = 2
                l.Transparency = 0.2
                l.Parent = k
            end
            
            SurvivorESPConnection = d.RenderStepped:Connect(function()
                for m, o in ipairs(c:GetChildren()) do
                    f(o, Color3.fromRGB(0, 255, 255)) -- 青色 (0, 255, 255)
                end
            end)
            
            -- 添加新加入的幸存者
            SurvivorAddedConnection = c.ChildAdded:Connect(function(o)
                f(o, Color3.fromRGB(0, 255, 255)) -- 青色 (0, 255, 255)
            end)
        else
            if SurvivorESPConnection then
                SurvivorESPConnection:Disconnect()
            end
            if SurvivorAddedConnection then
                SurvivorAddedConnection:Disconnect()
            end
            
            -- 清除所有幸存者ESP
            local a = workspace:WaitForChild("Players")
            local c = a:WaitForChild("Survivors")
            for _, o in ipairs(c:GetChildren()) do
                if o:IsA("Model") then
                    local i = o:FindFirstChild("HumanoidRootPart")
                    if i and i:FindFirstChild("playeresp") then
                        i.playeresp:Destroy()
                    end
                end
            end
        end
    end
})

Visual:AddToggle("KE", {
    Text = "杀手方框",
    Default = false,
    Callback = function(v)
        if v then
            local a = workspace:WaitForChild("Players")
            local b = a:WaitForChild("Killers")
            local d = game:GetService("RunService")
            local e = game:GetService("Players").LocalPlayer
            
            local function f(g, h)
                if not g:IsA("Model") then return end
                if g == e.Character then return end
                local i = g:FindFirstChild("HumanoidRootPart")
                if not i then return end
                if i:FindFirstChild("playeresp") then return end
                
                local j = Instance.new("BillboardGui")
                j.Name = "playeresp"
                j.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                j.Active = true
                j.AlwaysOnTop = true
                j.LightInfluence = 1.000
                j.Size = UDim2.new(3, 0, 5, 0)
                j.Adornee = i
                j.Parent = i
                
                local k = Instance.new("Frame")
                k.Name = "playershow"
                k.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                k.BackgroundTransparency = 1
                k.Size = UDim2.new(1, 0, 1, 0)
                k.Parent = j
                
                local l = Instance.new("UIStroke")
                l.Color = h
                l.Thickness = 2
                l.Transparency = 0.2
                l.Parent = k
            end
            
            KillerESPConnection = d.RenderStepped:Connect(function()
                for m, o in ipairs(b:GetChildren()) do
                    f(o, Color3.fromRGB(255, 0, 0)) -- 红色 (255, 0, 0)
                end
            end)
            
            -- 添加新加入的杀手
            KillerAddedConnection = b.ChildAdded:Connect(function(o)
                f(o, Color3.fromRGB(255, 0, 0)) -- 红色 (255, 0, 0)
            end)
        else
            if KillerESPConnection then
                KillerESPConnection:Disconnect()
            end
            if KillerAddedConnection then
                KillerAddedConnection:Disconnect()
            end
            
            -- 清除所有杀手ESP
            local a = workspace:WaitForChild("Players")
            local b = a:WaitForChild("Killers")
            for _, o in ipairs(b:GetChildren()) do
                if o:IsA("Model") then
                    local i = o:FindFirstChild("HumanoidRootPart")
                    if i and i:FindFirstChild("playeresp") then
                        i.playeresp:Destroy()
                    end
                end
            end
        end
    end
})





local togglePZ = Tabs.Esp:AddLeftGroupbox('绘制线条')

local players = game:GetService("Players")
local run_service = game:GetService("RunService")
local local_player = players.LocalPlayer
local camera = workspace.CurrentCamera

getgenv().cyberline_config = {
    survivors_enabled = false,
    killers_enabled = false,
    tracer_position = "top", 
    tracers = {}
}

togglePZ:AddDropdown("TracerPosition", {
    Values = { "上", "中", "下" },
    Default = 1, 
    Multi = false,
    Text = "血条显示方向",
    Callback = function(Value)
        getgenv().cyberline_config.tracer_position = Value
    end,
    Disabled = false,
    Visible = true,
})

togglePZ:AddToggle("SurvivorsTracers", {
    Text = "绘制幸存者线条",
    Default = false,
    Callback = function(value)
        getgenv().cyberline_config.survivors_enabled = value
        if not value then
            for instance, tracer in pairs(getgenv().cyberline_config.tracers) do
                if instance:IsDescendantOf(workspace.Players.Survivors) then
                    pcall(function() tracer:Remove() end)
                    getgenv().cyberline_config.tracers[instance] = nil
                end
            end
        end
    end
})

togglePZ:AddToggle("KillersTracers", {
    Text = "绘制杀手线条",
    Default = false,
    Callback = function(value)
        getgenv().cyberline_config.killers_enabled = value
        if not value then
            for instance, tracer in pairs(getgenv().cyberline_config.tracers) do
                if instance:IsDescendantOf(workspace.Players.Killers) then
                    pcall(function() tracer:Remove() end)
                    getgenv().cyberline_config.tracers[instance] = nil
                end
            end
        end
    end
})

local function create_tracer()
    local line = Drawing.new("Line")
    line.Thickness = 1
    line.Transparency = 1
    line.Visible = false
    return line
end

local function get_tracer_start_position()
    local position = getgenv().cyberline_config.tracer_position
    local viewport_size = camera.ViewportSize
    
    if position == "top" then
        return Vector2.new(viewport_size.X / 2, 0)
    elseif position == "central" then
        return Vector2.new(viewport_size.X / 2, viewport_size.Y / 2)
    elseif position == "below" then
        return Vector2.new(viewport_size.X / 2, viewport_size.Y)
    else
        return Vector2.new(viewport_size.X / 2, 0) 
    end
end

run_service.RenderStepped:Connect(function()
    for _, tracer in pairs(getgenv().cyberline_config.tracers) do
        tracer.Visible = false
    end

    local start_position = get_tracer_start_position()
    if getgenv().cyberline_config.survivors_enabled then
        for _, survivor in ipairs(workspace.Players.Survivors:GetChildren()) do
            if survivor:FindFirstChild("HumanoidRootPart") then
                local root_part = survivor.HumanoidRootPart
                local screen_pos, on_screen = camera:WorldToViewportPoint(root_part.Position)

                if not getgenv().cyberline_config.tracers[survivor] then
                    getgenv().cyberline_config.tracers[survivor] = create_tracer()
                    getgenv().cyberline_config.tracers[survivor].Color = Color3.fromRGB(0, 255, 255) 
                end

                local tracer = getgenv().cyberline_config.tracers[survivor]

                if on_screen then
                    tracer.From = start_position
                    tracer.To = Vector2.new(screen_pos.X, screen_pos.Y)
                    tracer.Visible = true
                else
                    tracer.Visible = false
                end
            end
        end
    end

    if getgenv().cyberline_config.killers_enabled then
        for _, killer in ipairs(workspace.Players.Killers:GetChildren()) do
            if killer:FindFirstChild("HumanoidRootPart") then
                local root_part = killer.HumanoidRootPart
                local screen_pos, on_screen = camera:WorldToViewportPoint(root_part.Position)

                if not getgenv().cyberline_config.tracers[killer] then
                    getgenv().cyberline_config.tracers[killer] = create_tracer()
                    getgenv().cyberline_config.tracers[killer].Color = Color3.fromRGB(255, 0, 0) 
                end

                local tracer = getgenv().cyberline_config.tracers[killer]

                if on_screen then
                    tracer.From = start_position
                    tracer.To = Vector2.new(screen_pos.X, screen_pos.Y)
                    tracer.Visible = true
                else
                    tracer.Visible = false
                end
            end
        end
    end
    
for instance, tracer in pairs(getgenv().cyberline_config.tracers) do
        if not instance:IsDescendantOf(workspace) then
            pcall(function() tracer:Remove() end)
            getgenv().cyberline_config.tracers[instance] = nil
        end
    end
end)

local Visual = Tabs.Esp:AddRightGroupbox("绘制高亮")


local HighlightSystem = {
    Enabled = false,
    Settings = {
        ShowSurvivors = true,
        ShowKillers = true,
        Colors = {
            Survivor = Color3.fromRGB(0, 255, 255), -- 青色
            Killer = Color3.fromRGB(204, 0, 0)      -- 暗红色
        },
        Transparency = {
            Fill = 0.9,
            Outline = 0
        }
    },
    Cache = {
        Highlights = {},
        Connections = {}
    }
}

-- ► 高亮核心功能 -----------------------------------
local function CreateHighlight(char, isKiller)
    local highlight = Instance.new("Highlight")
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = isKiller and HighlightSystem.Settings.Colors.Killer 
                                     or HighlightSystem.Settings.Colors.Survivor
    highlight.OutlineColor = highlight.FillColor
    highlight.FillTransparency = HighlightSystem.Settings.Transparency.Fill
    highlight.OutlineTransparency = HighlightSystem.Settings.Transparency.Outline
    highlight.Parent = char
    
    -- 血量变化监听
    local conn = char.Humanoid.HealthChanged:Connect(function()
        if not char:FindFirstChild("Humanoid") then conn:Disconnect() end
    end)
    
    char.Humanoid.Died:Connect(function()
        highlight.OutlineTransparency = 1
        conn:Disconnect()
    end)
    
    return highlight
end

local function UpdateHighlights()
    -- 清理无效高亮
    for char, highlight in pairs(HighlightSystem.Cache.Highlights) do
        if not char.Parent then
            highlight:Destroy()
            HighlightSystem.Cache.Highlights[char] = nil
        end
    end
    
    -- 更新幸存者
    if HighlightSystem.Settings.ShowSurvivors then
        for _, char in ipairs(workspace.Players.Survivors:GetDescendants()) do
            if char:IsA("Model") and char:FindFirstChild("Humanoid") then
                if not HighlightSystem.Cache.Highlights[char] then
                    HighlightSystem.Cache.Highlights[char] = CreateHighlight(char, false)
                end
            end
        end
    end
    
    -- 更新杀手
    if HighlightSystem.Settings.ShowKillers then
        for _, char in ipairs(workspace.Players.Killers:GetDescendants()) do
            if char:IsA("Model") and char:FindFirstChild("Humanoid") then
                if not HighlightSystem.Cache.Highlights[char] then
                    HighlightSystem.Cache.Highlights[char] = CreateHighlight(char, true)
                end
            end
        end
    end
end

-- ► UI控制按钮 -------------------------------------
-- 主开关
Visual:AddToggle("HL_MainToggle", {
    Text = "开启高亮绘制",
    Default = false,
    Callback = function(state)
        HighlightSystem.Enabled = state
        if state then
            HighlightSystem.Cache.Connections["Main"] = game:GetService("RunService").Heartbeat:Connect(UpdateHighlights)
            UpdateHighlights()
        else
            if HighlightSystem.Cache.Connections["Main"] then
                HighlightSystem.Cache.Connections["Main"]:Disconnect()
            end
            for _, h in pairs(HighlightSystem.Cache.Highlights) do h:Destroy() end
            HighlightSystem.Cache.Highlights = {}
        end
    end
})

-- 幸存者开关
Visual:AddToggle("HL_SurvivorToggle", {
    Text = "绘制幸存者",
    Default = true,
    Callback = function(state)
        HighlightSystem.Settings.ShowSurvivors = state
        UpdateHighlights()
    end
})

-- 杀手开关
Visual:AddToggle("HL_KillerToggle", {
    Text = "绘制杀手", 
    Default = true,
    Callback = function(state)
        HighlightSystem.Settings.ShowKillers = state
        UpdateHighlights()
    end
})

-- 透明度控制
Visual:AddSlider("HL_FillTransparency", {
    Text = "透明度",
    Min = 0,
    Max = 1,
    Default = 0.9,
    Rounding = 1,
    Callback = function(value)
        HighlightSystem.Settings.Transparency.Fill = value
        for _, h in pairs(HighlightSystem.Cache.Highlights) do
            h.FillTransparency = value
        end
    end
})

Visual:AddSlider("HL_OutlineTransparency", {
    Text = "轮廓透明度",
    Min = 0,
    Max = 1,
    Default = 0,
    Rounding = 1,
    Callback = function(value)
        HighlightSystem.Settings.Transparency.Outline = value
        for _, h in pairs(HighlightSystem.Cache.Highlights) do
            h.OutlineTransparency = value
        end
    end
})

local Visual = Tabs.Esp:AddLeftGroupbox("绘制血量")


-- 血量条设置
local HealthBarSettings = {
    ShowSurvivorBars = true,
    ShowKillerBars = true,
    BarWidth = 100,      -- 固定宽度
    BarHeight = 5,       -- 固定高度
    TextSize = 14,       -- 固定文字大小
    BarOffset = Vector2.new(0, -50), -- 基础偏移（头顶）
    TextOffset = Vector2.new(0, -60)  -- 文字偏移
}

-- 预设颜色方案
local ColorPresets = {
    Survivor = {
        FullHealth = Color3.fromRGB(0, 255, 255),    -- 青色(满血)
        HalfHealth = Color3.fromRGB(0, 255, 0),      -- 绿色(半血)
        LowHealth = Color3.fromRGB(255, 165, 0)      -- 橙色(低血)
    },
    Killer = {
        FullHealth = Color3.fromRGB(255, 0, 0),      -- 红色(满血)
        HalfHealth = Color3.fromRGB(255, 165, 0),    -- 橙色(半血)
        LowHealth = Color3.fromRGB(255, 255, 0)      -- 黄色(低血)
    },
    Common = {
        Background = Color3.fromRGB(50, 50, 50),
        Outline = Color3.fromRGB(0, 0, 0),
        Text = Color3.fromRGB(255, 255, 255)        -- 白色文字
    }
}

-- 存储所有绘制对象
local HealthBarDrawings = {}

-- 创建血量条绘制对象
local function createHealthBarDrawing()
    local drawing = {
        background = Drawing.new("Square"),
        bar = Drawing.new("Square"),
        outline = Drawing.new("Square"),
        text = Drawing.new("Text")
    }
    
    -- 背景设置
    drawing.background.Thickness = 1
    drawing.background.Filled = true
    drawing.background.Color = ColorPresets.Common.Background
    
    -- 血量条设置
    drawing.bar.Thickness = 1
    drawing.bar.Filled = true
    
    -- 边框设置
    drawing.outline.Thickness = 2
    drawing.outline.Filled = false
    drawing.outline.Color = ColorPresets.Common.Outline
    
    -- 文字设置
    drawing.text.Center = true
    drawing.text.Outline = true
    drawing.text.Font = 2
    drawing.text.Color = ColorPresets.Common.Text
    
    return drawing
end

-- 根据血量获取颜色
local function getHealthColor(humanoid, isKiller)
    local healthPercent = (humanoid.Health / humanoid.MaxHealth) * 100
    
    if isKiller then
        if healthPercent > 50 then
            return ColorPresets.Killer.FullHealth
        elseif healthPercent > 25 then
            return ColorPresets.Killer.HalfHealth
        else
            return ColorPresets.Killer.LowHealth
        end
    else
        if healthPercent > 75 then
            return ColorPresets.Survivor.FullHealth
        elseif healthPercent > 35 then
            return ColorPresets.Survivor.HalfHealth
        else
            return ColorPresets.Survivor.LowHealth
        end
    end
end

-- 获取角色头顶位置
local function get_head_position(character)
    local head = character:FindFirstChild("Head")
    if head then
        return head.Position + Vector3.new(0, 1.5, 0) -- 稍微高于头部
    end
    return character:GetModelCFrame().Position
end

-- 更新血量条
local function updateHealthBars()
    local camera = workspace.CurrentCamera
    local localPlayer = Players.LocalPlayer
    
    -- 处理幸存者
    if HealthBarSettings.ShowSurvivorBars then
        local survivors = workspace.Players:FindFirstChild("Survivors") or workspace:FindFirstChild("Survivors")
        if survivors then
            for _, survivor in ipairs(survivors:GetChildren()) do
                if survivor:IsA("Model") and survivor ~= localPlayer.Character then -- 不显示自身血条
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    
                    if humanoid then
                        -- 获取或创建绘制对象
                        if not HealthBarDrawings[survivor] then
                            HealthBarDrawings[survivor] = createHealthBarDrawing()
                        end
                        
                        local drawing = HealthBarDrawings[survivor]
                        local headPos = get_head_position(survivor)
                        local screenPos, onScreen = camera:WorldToViewportPoint(headPos)
                        
                        if onScreen then
                            -- 计算血量百分比
                            local healthPercent = math.floor((humanoid.Health / humanoid.MaxHealth) * 100)
                            local healthBarWidth = HealthBarSettings.BarWidth * (healthPercent / 100)
                            
                            -- 水平条位置（头顶）
                            local barPos = Vector2.new(
                                screenPos.X + HealthBarSettings.BarOffset.X - (HealthBarSettings.BarWidth / 2),
                                screenPos.Y + HealthBarSettings.BarOffset.Y
                            )
                            
                            -- 背景和边框
                            drawing.background.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.background.Position = barPos
                            drawing.background.Visible = true
                            
                            drawing.outline.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.outline.Position = barPos
                            drawing.outline.Visible = true
                            
                            -- 血量条
                            drawing.bar.Color = getHealthColor(humanoid, false)
                            drawing.bar.Size = Vector2.new(healthBarWidth, HealthBarSettings.BarHeight)
                            drawing.bar.Position = barPos
                            drawing.bar.Visible = true
                            
                            -- 文字
                            drawing.text.Text = tostring(healthPercent) .. "%"
                            drawing.text.Size = HealthBarSettings.TextSize
                            drawing.text.Position = Vector2.new(
                                screenPos.X + HealthBarSettings.TextOffset.X,
                                screenPos.Y + HealthBarSettings.TextOffset.Y
                            )
                            drawing.text.Visible = true
                        else
                            -- 不在屏幕内则隐藏
                            for _, obj in pairs(drawing) do
                                obj.Visible = false
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- 处理杀手
    if HealthBarSettings.ShowKillerBars then
        local killers = workspace.Players:FindFirstChild("Killers") or workspace:FindFirstChild("Killers")
        if killers then
            for _, killer in ipairs(killers:GetChildren()) do
                if killer:IsA("Model") and killer ~= localPlayer.Character then -- 不显示自身血条
                    local humanoid = killer:FindFirstChildOfClass("Humanoid")
                    
                    if humanoid then
                        -- 获取或创建绘制对象
                        if not HealthBarDrawings[killer] then
                            HealthBarDrawings[killer] = createHealthBarDrawing()
                        end
                        
                        local drawing = HealthBarDrawings[killer]
                        local headPos = get_head_position(killer)
                        local screenPos, onScreen = camera:WorldToViewportPoint(headPos)
                        
                        if onScreen then
                            -- 计算血量百分比
                            local healthPercent = math.floor((humanoid.Health / humanoid.MaxHealth) * 100)
                            local healthBarWidth = HealthBarSettings.BarWidth * (healthPercent / 100)
                            
                            -- 水平条位置（头顶）
                            local barPos = Vector2.new(
                                screenPos.X + HealthBarSettings.BarOffset.X - (HealthBarSettings.BarWidth / 2),
                                screenPos.Y + HealthBarSettings.BarOffset.Y
                            )
                            
                            -- 背景和边框
                            drawing.background.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.background.Position = barPos
                            drawing.background.Visible = true
                            
                            drawing.outline.Size = Vector2.new(HealthBarSettings.BarWidth, HealthBarSettings.BarHeight)
                            drawing.outline.Position = barPos
                            drawing.outline.Visible = true
                            
                            -- 血量条
                            drawing.bar.Color = getHealthColor(humanoid, true)
                            drawing.bar.Size = Vector2.new(healthBarWidth, HealthBarSettings.BarHeight)
                            drawing.bar.Position = barPos
                            drawing.bar.Visible = true
                            
                            -- 文字
                            drawing.text.Text = tostring(healthPercent) .. "%"
                            drawing.text.Size = HealthBarSettings.TextSize
                            drawing.text.Position = Vector2.new(
                                screenPos.X + HealthBarSettings.TextOffset.X,
                                screenPos.Y + HealthBarSettings.TextOffset.Y
                            )
                            drawing.text.Visible = true
                        else
                            -- 不在屏幕内则隐藏
                            for _, obj in pairs(drawing) do
                                obj.Visible = false
                            end
                        end
                    end
                end
            end
        end
    end
end

-- 清理血量条
local function cleanupHealthBars()
    for _, drawing in pairs(HealthBarDrawings) do
        for _, obj in pairs(drawing) do
            if obj then
                obj:Remove()
            end
        end
    end
    HealthBarDrawings = {}
end

-- 主开关
Visual:AddToggle("HealthBarsToggle", {
    Text = "开启血量绘制",
    Default = false,
    Callback = function(enabled)
        if enabled then
            -- 初始化连接
            if not HealthBarSettings.connection then
                HealthBarSettings.connection = game:GetService("RunService").RenderStepped:Connect(updateHealthBars)
            end
            
            -- 监听角色移除
            if not HealthBarSettings.removedConnection then
                HealthBarSettings.removedConnection = workspace.DescendantRemoving:Connect(function(descendant)
                    if HealthBarDrawings[descendant] then
                        for _, obj in pairs(HealthBarDrawings[descendant]) do
                            obj:Remove()
                        end
                        HealthBarDrawings[descendant] = nil
                    end
                end)
            end
        else
            -- 关闭连接
            if HealthBarSettings.connection then
                HealthBarSettings.connection:Disconnect()
                HealthBarSettings.connection = nil
            end
            
            if HealthBarSettings.removedConnection then
                HealthBarSettings.removedConnection:Disconnect()
                HealthBarSettings.removedConnection = nil
            end
            
            -- 清理绘制对象
            cleanupHealthBars()
        end
    end
})

-- 幸存者开关
Visual:AddToggle("ShowSurvivorBars", {
    Text = "绘制幸存者血量",
    Default = true,
    Callback = function(enabled)
        HealthBarSettings.ShowSurvivorBars = enabled
    end
})

-- 杀手开关
Visual:AddToggle("ShowKillerBars", {
    Text = "绘制杀手血量",
    Default = true,
    Callback = function(enabled)
        HealthBarSettings.ShowKillerBars = enabled
    end
})




local Visual = Tabs.Esp:AddRightGroupbox("血容量[text]")


local camera = workspace.CurrentCamera
local localPlayer = game:GetService("Players").LocalPlayer

Visual:AddToggle("SurvivorHealth", {
    Text = "幸存者血容量",
    Default = false,
    Callback = function(v)
        if v then
            local sur = workspace.Players.Survivors
            
            local function survivoresp(char)
                local billboard = Instance.new("BillboardGui")
                billboard.Size = UDim2.new(3, 0, 1, 0)
                billboard.StudsOffset = Vector3.new(0, 1.5, 0)
                billboard.Adornee = char.Head
                billboard.Parent = char.Head
                billboard.AlwaysOnTop = true
                
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.Position = UDim2.new(0, 0, 0, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextScaled = false
                textLabel.Text = "blood volume: "..char.Humanoid.Health.."/"..char.Humanoid.MaxHealth
                textLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
                textLabel.Font = Enum.Font.Arcade
                textLabel.Parent = billboard

              
                local distanceUpdate
                distanceUpdate = game:GetService("RunService").RenderStepped:Connect(function()
                    if char:FindFirstChild("Head") and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (char.Head.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                        
                        local textSize = math.clamp(30 - (distance / 2), 12, 20)
                        textLabel.TextSize = textSize
                    end
                end)

                local healthUpdate = char:FindFirstChild("Humanoid").HealthChanged:Connect(function()
                    textLabel.Text = "blood volume: "..char:FindFirstChild("Humanoid").Health.."/"..char:FindFirstChild("Humanoid").MaxHealth
                end)

                char:FindFirstChild("Humanoid").Died:Connect(function()
                    distanceUpdate:Disconnect()
                    healthUpdate:Disconnect()
                    textLabel.Text = ""
                end)

                return {billboard = billboard, connections = {distanceUpdate, healthUpdate}}
            end

            getgenv().SurvivorHealthConnections = {
                Added = sur.DescendantAdded:Connect(function(v)
                    if v:IsA("Model") and v:FindFirstChild("Humanoid") then
                        repeat wait() until v:FindFirstChild("Humanoid")
                        survivoresp(v)
                    end
                end)
            }

            for _,v in pairs(sur:GetDescendants()) do
                if v:IsA("Model") and v:FindFirstChild("Humanoid") then
                    repeat wait() until v:FindFirstChild("Humanoid")
                    survivoresp(v)
                end
            end
        else
            if getgenv().SurvivorHealthConnections then
                getgenv().SurvivorHealthConnections.Added:Disconnect()
            end
            
            for _,v in pairs(workspace.Players.Survivors:GetDescendants()) do
                if v:IsA("Model") and v:FindFirstChild("Head") then
                    for _,child in pairs(v.Head:GetChildren()) do
                        if child:IsA("BillboardGui") then
                            child:Destroy()
                        end
                    end
                end
            end
        end
    end
})

Visual:AddToggle("KillerHealth", {
    Text = "杀手血容量",
    Default = false,
    Callback = function(v)
        if v then
            local kil = workspace.Players.Killers
            
            local function killeresp(char)
                local billboard = Instance.new("BillboardGui")
                billboard.Size = UDim2.new(3, 0, 1, 0)
                billboard.StudsOffset = Vector3.new(0, 1.5, 0)
                billboard.Adornee = char.Head
                billboard.Parent = char.Head
                billboard.AlwaysOnTop = true
                
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.Position = UDim2.new(0, 0, 0, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextScaled = false
                textLabel.Text = "blood volume: "..char.Humanoid.Health.."/"..char.Humanoid.MaxHealth
                textLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                textLabel.Font = Enum.Font.Arcade
                textLabel.Parent = billboard

                -- 添加距离检测更新
                local distanceUpdate
                distanceUpdate = game:GetService("RunService").RenderStepped:Connect(function()
                    if char:FindFirstChild("Head") and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (char.Head.Position - localPlayer.Character.HumanoidRootPart.Position).Magnitude
                        -- 根据距离动态调整文字大小 (10-30米范围内变化)
                        local textSize = math.clamp(30 - (distance / 2), 12, 20)
                        textLabel.TextSize = textSize
                    end
                end)

                local healthUpdate = char:FindFirstChild("Humanoid").HealthChanged:Connect(function()
                    textLabel.Text = "blood volume: "..char:FindFirstChild("Humanoid").Health.."/"..char:FindFirstChild("Humanoid").MaxHealth
                end)

                char:FindFirstChild("Humanoid").Died:Connect(function()
                    distanceUpdate:Disconnect()
                    healthUpdate:Disconnect()
                    textLabel.Text = ""
                end)

                return {billboard = billboard, connections = {distanceUpdate, healthUpdate}}
            end

            getgenv().KillerHealthConnections = {
                Added = kil.DescendantAdded:Connect(function(v)
                    if v:IsA("Model") and v:FindFirstChild("Humanoid") then
                        repeat wait() until v:FindFirstChild("Humanoid")
                        killeresp(v)
                    end
                end)
            }

            for _,v in pairs(kil:GetDescendants()) do
                if v:IsA("Model") and v:FindFirstChild("Humanoid") then
                    repeat wait() until v:FindFirstChild("Humanoid")
                    killeresp(v)
                end
            end
        else
            if getgenv().KillerHealthConnections then
                getgenv().KillerHealthConnections.Added:Disconnect()
            end
            
            for _,v in pairs(workspace.Players.Killers:GetDescendants()) do
                if v:IsA("Model") and v:FindFirstChild("Head") then
                    for _,child in pairs(v.Head:GetChildren()) do
                        if child:IsA("BillboardGui") then
                            child:Destroy()
                        end
                    end
                end
            end
        end
    end
})



local Visual = Tabs.Esp:AddLeftGroupbox("绘制名称")

local NameTagSettings = {
    ShowSurvivorNames = true,
    ShowKillerNames = true,
    BaseTextSize = 14,
    MinTextSize = 10,
    MaxTextSize = 20,
    TextOffset = Vector3.new(0, 3, 0),
    DistanceScale = {
        MinDistance = 10,
        MaxDistance = 50
    },
    SurvivorColor = Color3.fromRGB(0, 191, 255),
    KillerColor = Color3.fromRGB(255, 0, 0),
    OutlineColor = Color3.fromRGB(0, 0, 0),
    ShowDistance = true
}

local NameTagDrawings = {}

local function createNameTagDrawing()
    local drawing = Drawing.new("Text")
    drawing.Size = NameTagSettings.BaseTextSize
    drawing.Center = true
    drawing.Outline = true
    drawing.OutlineColor = NameTagSettings.OutlineColor
    drawing.Font = 2
    return drawing
end

local function getHeadPosition(character)
    local head = character:FindFirstChild("Head")
    if head then
        local headHeight = head.Size.Y
        return head.Position + Vector3.new(0, headHeight + 0.5, 0)
    end
    return character:GetPivot().Position
end

local function cleanupInvalidDrawings()
    local survivors = workspace.Players:FindFirstChild("Survivors")
    local killers = workspace.Players:FindFirstChild("Killers")
    
    local validCharacters = {}
    if survivors then
        for _, survivor in ipairs(survivors:GetChildren()) do
            if survivor:IsA("Model") then
                validCharacters[survivor] = true
            end
        end
    end
    if killers then
        for _, killer in ipairs(killers:GetChildren()) do
            if killer:IsA("Model") then
                validCharacters[killer] = true
            end
        end
    end
    
    for model, drawing in pairs(NameTagDrawings) do
        if not validCharacters[model] then
            drawing:Remove()
            NameTagDrawings[model] = nil
        end
    end
end

local function updateNameTags()
    local camera = workspace.CurrentCamera
    local localPlayer = Players.LocalPlayer
    local localCharacter = localPlayer.Character
    local localRoot = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")

    if not localRoot then return end
    
    cleanupInvalidDrawings()

    if NameTagSettings.ShowSurvivorNames then
        local survivors = workspace.Players:FindFirstChild("Survivors")
        if survivors then
            for _, survivor in ipairs(survivors:GetChildren()) do
                if survivor:IsA("Model") and survivor ~= localCharacter then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    
                    if not NameTagDrawings[survivor] then
                        NameTagDrawings[survivor] = createNameTagDrawing()
                    end
                    
                    local drawing = NameTagDrawings[survivor]
                    
                    if not humanoid or humanoid.Health <= 0 then
                        drawing.Visible = false
                        continue
                    end
                    
                    local headPos = getHeadPosition(survivor)
                    local screenPos, onScreen = camera:WorldToViewportPoint(headPos + NameTagSettings.TextOffset)
                    
                    if onScreen then
                        local distance = (headPos - localRoot.Position).Magnitude
                        local scale = math.clamp(
                            1 - (distance - NameTagSettings.DistanceScale.MinDistance) / 
                            (NameTagSettings.DistanceScale.MaxDistance - NameTagSettings.DistanceScale.MinDistance), 
                            0.3, 1
                        )
                        
                        local textSize = math.floor(NameTagSettings.BaseTextSize * scale)
                        textSize = math.clamp(textSize, NameTagSettings.MinTextSize, NameTagSettings.MaxTextSize)
                        
                        local displayText = survivor.Name
                        if NameTagSettings.ShowDistance then
                            displayText = string.format("%s [%d]", survivor.Name, math.floor(distance))
                        end
                        
                        drawing.Text = displayText
                        drawing.Color = NameTagSettings.SurvivorColor
                        drawing.Size = textSize
                        drawing.Position = Vector2.new(screenPos.X, screenPos.Y)
                        drawing.Visible = true
                    else
                        drawing.Visible = false
                    end
                end
            end
        end
    end

    if NameTagSettings.ShowKillerNames then
        local killers = workspace.Players:FindFirstChild("Killers")
        if killers then
            for _, killer in ipairs(killers:GetChildren()) do
                if killer:IsA("Model") then
                    local humanoid = killer:FindFirstChildOfClass("Humanoid")
                    
                    if not NameTagDrawings[killer] then
                        NameTagDrawings[killer] = createNameTagDrawing()
                    end
                    
                    local drawing = NameTagDrawings[killer]
                    
                    if not humanoid or humanoid.Health <= 0 then
                        drawing.Visible = false
                        continue
                    end
                    
                    local headPos = getHeadPosition(killer)
                    local screenPos, onScreen = camera:WorldToViewportPoint(headPos + NameTagSettings.TextOffset)
                    
                    if onScreen then
                        local distance = (headPos - localRoot.Position).Magnitude
                        local scale = math.clamp(
                            1 - (distance - NameTagSettings.DistanceScale.MinDistance) / 
                            (NameTagSettings.DistanceScale.MaxDistance - NameTagSettings.DistanceScale.MinDistance), 
                            0.3, 1
                        )
                        
                        local textSize = math.floor(NameTagSettings.BaseTextSize * scale)
                        textSize = math.clamp(textSize, NameTagSettings.MinTextSize, NameTagSettings.MaxTextSize)
                        
                        local displayText = killer.Name
                        if NameTagSettings.ShowDistance then
                            displayText = string.format("%s [%dm]", killer.Name, math.floor(distance))
                        end
                        
                        drawing.Text = displayText
                        drawing.Color = NameTagSettings.KillerColor
                        drawing.Size = textSize
                        drawing.Position = Vector2.new(screenPos.X, screenPos.Y)
                        drawing.Visible = true
                    else
                        drawing.Visible = false
                    end
                end
            end
        end
    end
end

local function cleanupNameTags()
    for _, drawing in pairs(NameTagDrawings) do
        if drawing then
            drawing:Remove()
        end
    end
    NameTagDrawings = {}
end

Visual:AddToggle("NameTagsToggle", {
    Text = "开启绘制名称",
    Default = false,
    Callback = function(enabled)
        if enabled then
            if not NameTagSettings.connection then
                NameTagSettings.connection = game:GetService("RunService").RenderStepped:Connect(updateNameTags)
            end
            
            if not NameTagSettings.removedConnection then
                NameTagSettings.removedConnection = game:GetService("Players").PlayerRemoving:Connect(function(player)
                    for model, drawing in pairs(NameTagDrawings) do
                        if model.Name == player.Name then
                            drawing:Remove()
                            NameTagDrawings[model] = nil
                        end
                    end
                end)
            end
        else
            if NameTagSettings.connection then
                NameTagSettings.connection:Disconnect()
                NameTagSettings.connection = nil
            end
            
            if NameTagSettings.removedConnection then
                NameTagSettings.removedConnection:Disconnect()
                NameTagSettings.removedConnection = nil
            end
            
            cleanupNameTags()
        end
    end
})

Visual:AddToggle("ShowSurvivorNames", {
    Text = "绘制幸存者名字",
    Default = true,
    Callback = function(enabled)
        NameTagSettings.ShowSurvivorNames = enabled
    end
})

Visual:AddToggle("ShowKillerNames", {
    Text = "绘制杀手名字",
    Default = true,
    Callback = function(enabled)
        NameTagSettings.ShowKillerNames = enabled
    end
})

Visual:AddToggle("ShowDistance", {
    Text = "绘制距离",
    Default = true,
    Callback = function(enabled)
        NameTagSettings.ShowDistance = enabled
    end
})







local Visual   = Tabs.Esp:AddRightGroupbox('绘制发电机')

Visual:AddToggle("RealGeneratorESP", {
    Text = "绘制发电机",
    Default = false,
    Callback = function(enabled)
        if not _G.RealGeneratorESP then
            _G.RealGeneratorESP = {
                Active = false,
                Data = {},
                Connections = {}
            }
        end
        
        if not enabled then
            if _G.RealGeneratorESP.Active then
                for _, connection in pairs(_G.RealGeneratorESP.Connections) do
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end
                
                for gen, data in pairs(_G.RealGeneratorESP.Data) do
                    if type(data) == "table" then
                        if data.Billboard and data.Billboard.Parent then
                            data.Billboard:Destroy()
                        end
                        if data.DistanceBillboard and data.DistanceBillboard.Parent then
                            data.DistanceBillboard:Destroy()
                        end
                        if data.Highlight and data.Highlight.Parent then
                            data.Highlight:Destroy()
                        end
                    end
                end
                
                _G.RealGeneratorESP.Data = {}
                _G.RealGeneratorESP.Connections = {}
                _G.RealGeneratorESP.Active = false
            end
            return
        end
        
        if _G.RealGeneratorESP.Active then
            return
        end
        
        _G.RealGeneratorESP.Active = true
        
        local scanInterval = 1.0
        local lastScanTime = 0
        local maxGenerators = 20
        
        local distanceSettings = {
            MinDistance = 5,
            MaxDistance = 500,
            MinScale = 0.8,
            MaxScale = 1.5,
            MinTextSize = 8,
            MaxTextSize = 10
        }
        
        local function updateGeneratorESP(gen, data)
            if not gen or not gen.Parent or not gen:FindFirstChild("Main") then
                return false
            end
            
            if table.getn(_G.RealGeneratorESP.Data) > maxGenerators then
                return false
            end
            
            if gen:FindFirstChild("Progress") then
                local progress = gen.Progress.Value
                if progress >= 99 then
                    return false
                end
                
                if data.TextLabel then
                    data.TextLabel.Text = string.format("Progress: %d%%", progress)
                end
                
                local character = game:GetService("Players").LocalPlayer.Character
                local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
                
                if humanoidRootPart and data.DistanceLabel then
                    local distance = (gen.Main.Position - humanoidRootPart.Position).Magnitude
                    
                    data.DistanceLabel.Text = string.format("Distance: %dm", math.floor(distance))
                    
                    local distanceRatio = math.clamp(
                        (distance - distanceSettings.MinDistance) / 
                        (distanceSettings.MaxDistance - distanceSettings.MinDistance),
                        0, 1
                    )
                    
                    local scale = distanceSettings.MinScale + 
                        distanceRatio * (distanceSettings.MaxScale - distanceSettings.MinScale)
                    
                    local textSize = distanceSettings.MinTextSize + 
                        distanceRatio * (distanceSettings.MaxTextSize - distanceSettings.MinTextSize)
                    
                    if data.Billboard then 
                        data.Billboard.Size = UDim2.new(4 * scale, 0, 1 * scale, 0)
                        data.Billboard.Enabled = true
                    end
                    
                    if data.DistanceBillboard then 
                        data.DistanceBillboard.Size = UDim2.new(4 * scale, 0, 1 * scale, 0)
                        data.DistanceBillboard.Enabled = true
                    end
                    
                    if data.TextLabel then 
                        data.TextLabel.TextSize = textSize
                        data.TextLabel.Visible = true
                    end
                    
                    if data.DistanceLabel then 
                        data.DistanceLabel.TextSize = textSize
                        data.DistanceLabel.Visible = true
                    end
                    
                    if data.Highlight then
                        data.Highlight.Enabled = true
                        local transparency = math.clamp((distance - 50) / 100, 0, 0.4)
                        data.Highlight.FillTransparency = 0.85 + (transparency * 0.5)
                        data.Highlight.OutlineColor = Color3.fromRGB(0, 255, 0) -- 绿色
                        data.Highlight.FillColor = Color3.fromRGB(0, 255, 0)
                    end
                end
            end
            
            return true
        end
        
        local function createGeneratorESP(gen)
            if not gen or not gen:FindFirstChild("Main") or _G.RealGeneratorESP.Data[gen] then 
                return 
            end
            
            if table.getn(_G.RealGeneratorESP.Data) >= maxGenerators then
                return
            end
            
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "RealGeneratorESP"
            billboard.Size = UDim2.new(4, 0, 1, 0)
            billboard.StudsOffset = Vector3.new(0, 2.5, 0)
            billboard.Adornee = gen.Main
            billboard.Parent = gen.Main
            billboard.AlwaysOnTop = true
            billboard.Enabled = true
            
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 0.5, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.TextScaled = false
            textLabel.Text = "真电机加载中..."
            textLabel.TextColor3 = Color3.fromRGB(0, 255, 0) -- 绿色
            textLabel.Font = Enum.Font.Arcade
            textLabel.TextStrokeTransparency = 0
            textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.TextSize = 8
            textLabel.Parent = billboard
            
            local distanceBillboard = Instance.new("BillboardGui")
            distanceBillboard.Name = "RealGeneratorDistanceESP"
            distanceBillboard.Size = UDim2.new(4, 0, 1, 0)
            distanceBillboard.StudsOffset = Vector3.new(0, 3.5, 0)
            distanceBillboard.Adornee = gen.Main
            distanceBillboard.Parent = gen.Main
            distanceBillboard.AlwaysOnTop = true
            distanceBillboard.Enabled = true
            
            local distanceLabel = Instance.new("TextLabel")
            distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
            distanceLabel.BackgroundTransparency = 1
            distanceLabel.TextScaled = false
            distanceLabel.Text = "计算距离中..."
            distanceLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
            distanceLabel.Font = Enum.Font.Arcade
            distanceLabel.TextStrokeTransparency = 0
            distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            distanceLabel.TextSize = 8
            distanceLabel.Parent = distanceBillboard
            
            local highlight = Instance.new("Highlight")
            highlight.Name = "RealGeneratorHighlight"
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.OutlineColor = Color3.fromRGB(0, 255, 0) -- 绿色
            highlight.FillColor = Color3.fromRGB(0, 255, 0)
            highlight.FillTransparency = 0.9
            highlight.OutlineTransparency = 0
            highlight.Parent = gen
            
            _G.RealGeneratorESP.Data[gen] = {
                Billboard = billboard,
                DistanceBillboard = distanceBillboard,
                TextLabel = textLabel,
                DistanceLabel = distanceLabel,
                Highlight = highlight
            }
            
            local destroyConnection
            destroyConnection = gen.Destroying:Connect(function()
                if _G.RealGeneratorESP.Data[gen] then
                    if _G.RealGeneratorESP.Data[gen].Billboard then 
                        _G.RealGeneratorESP.Data[gen].Billboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].DistanceBillboard then 
                        _G.RealGeneratorESP.Data[gen].DistanceBillboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].Highlight then 
                        _G.RealGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    _G.RealGeneratorESP.Data[gen] = nil
                end
                if destroyConnection then
                    destroyConnection:Disconnect()
                end
            end)
            
            table.insert(_G.RealGeneratorESP.Connections, destroyConnection)
        end
        
        local function scanGenerators()
            local mapFolder = workspace:FindFirstChild("Map")
            if mapFolder then
                local ingameFolder = mapFolder:FindFirstChild("Ingame")
                if ingameFolder then
                    local mapSubFolder = ingameFolder:FindFirstChild("Map")
                    if mapSubFolder then
                        local generators = mapSubFolder:GetDescendants()
                        for _, gen in pairs(generators) do
                            if gen:IsA("Model") and gen:FindFirstChild("Main") and gen.Name == "Generator" then
                                createGeneratorESP(gen)
                            end
                        end
                    end
                end
            end
        end
        
        local mainConnection
        local mapFolder = workspace:FindFirstChild("Map")
        if mapFolder then
            local ingameFolder = mapFolder:FindFirstChild("Ingame")
            if ingameFolder then
                local mapSubFolder = ingameFolder:FindFirstChild("Map")
                if mapSubFolder then
                    mainConnection = mapSubFolder.DescendantAdded:Connect(function(v)
                        if v:IsA("Model") and v:FindFirstChild("Main") and v.Name == "Generator" then
                            createGeneratorESP(v)
                        end
                    end)
                end
            end
        end
        
        if mainConnection then
            table.insert(_G.RealGeneratorESP.Connections, mainConnection)
        end
        
        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
            lastScanTime = lastScanTime + deltaTime
            if lastScanTime >= scanInterval then
                lastScanTime = 0
                scanGenerators()
            end
            
            local gensToRemove = {}
            for gen, data in pairs(_G.RealGeneratorESP.Data) do
                if not gen or not gen.Parent then
                    table.insert(gensToRemove, gen)
                else
                    if not updateGeneratorESP(gen, data) then
                        table.insert(gensToRemove, gen)
                    end
                end
            end
            
            for _, gen in ipairs(gensToRemove) do
                if _G.RealGeneratorESP.Data[gen] then
                    if _G.RealGeneratorESP.Data[gen].Billboard then 
                        _G.RealGeneratorESP.Data[gen].Billboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].DistanceBillboard then 
                        _G.RealGeneratorESP.Data[gen].DistanceBillboard:Destroy() 
                    end
                    if _G.RealGeneratorESP.Data[gen].Highlight then 
                        _G.RealGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    _G.RealGeneratorESP.Data[gen] = nil
                end
            end
        end)
        
        table.insert(_G.RealGeneratorESP.Connections, heartbeatConnection)
        
        scanGenerators()
    end
})

-- 假电机ESP
Visual:AddToggle("FakeGeneratorESP", {
    Text = "绘制假发电机",
    Default = false,
    Callback = function(enabled)
        if not _G.FakeGeneratorESP then
            _G.FakeGeneratorESP = {
                Active = false,
                Data = {},
                Connections = {}
            }
        end
        
        if not enabled then
            if _G.FakeGeneratorESP.Active then
                for _, connection in pairs(_G.FakeGeneratorESP.Connections) do
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end
                
                for gen, data in pairs(_G.FakeGeneratorESP.Data) do
                    if type(data) == "table" then
                        if data.Highlight and data.Highlight.Parent then
                            data.Highlight:Destroy()
                        end
                        if data.NameLabel and data.NameLabel.Parent then
                            data.NameLabel:Destroy()
                        end
                    end
                end
                
                _G.FakeGeneratorESP.Data = {}
                _G.FakeGeneratorESP.Connections = {}
                _G.FakeGeneratorESP.Active = false
            end
            return
        end
        
        if _G.FakeGeneratorESP.Active then
            _G.FakeGeneratorESP.Callback(false)
        end
        
        _G.FakeGeneratorESP.Active = true
        
        local scanInterval = 1.0
        local lastScanTime = 0
        
        local function createFakeGeneratorESP(gen)
            if not gen or not gen:FindFirstChild("Main") or _G.FakeGeneratorESP.Data[gen] then 
                return 
            end
            
            local highlight = Instance.new("Highlight")
            highlight.Name = "FakeGeneratorHighlight"
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
            highlight.FillColor = Color3.fromRGB(255, 0, 0)
            highlight.FillTransparency = 0.9
            highlight.OutlineTransparency = 0
            highlight.Parent = gen
            
            local nameBillboard = Instance.new("BillboardGui")
            nameBillboard.Name = "FakeGeneratorNameESP"
            nameBillboard.Size = UDim2.new(4, 0, 1, 0)
            nameBillboard.StudsOffset = Vector3.new(0, 2.5, 0)
            nameBillboard.Adornee = gen.Main
            nameBillboard.Parent = gen.Main
            nameBillboard.AlwaysOnTop = true
            nameBillboard.Enabled = true
            
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 1, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.TextScaled = false
            nameLabel.Text = "Fake Generator"
            nameLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            nameLabel.Font = Enum.Font.Arcade
            nameLabel.TextStrokeTransparency = 0
            nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            nameLabel.TextSize = 12
            nameLabel.Parent = nameBillboard
            
            _G.FakeGeneratorESP.Data[gen] = {
                Highlight = highlight,
                NameLabel = nameLabel,
                NameBillboard = nameBillboard
            }
            
            local destroyConnection
            destroyConnection = gen.Destroying:Connect(function()
                if _G.FakeGeneratorESP.Data[gen] then
                    if _G.FakeGeneratorESP.Data[gen].Highlight then 
                        _G.FakeGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    if _G.FakeGeneratorESP.Data[gen].NameLabel then 
                        _G.FakeGeneratorESP.Data[gen].NameLabel:Destroy() 
                    end
                    if _G.FakeGeneratorESP.Data[gen].NameBillboard then 
                        _G.FakeGeneratorESP.Data[gen].NameBillboard:Destroy() 
                    end
                    _G.FakeGeneratorESP.Data[gen] = nil
                end
                if destroyConnection then
                    destroyConnection:Disconnect()
                end
            end)
            
            table.insert(_G.FakeGeneratorESP.Connections, destroyConnection)
        end
        
        local function scanGenerators()
            local mapFolder = workspace:FindFirstChild("Map")
            if mapFolder then
                local ingameFolder = mapFolder:FindFirstChild("Ingame")
                if ingameFolder then
                    local mapSubFolder = ingameFolder:FindFirstChild("Map")
                    if mapSubFolder then
                        local generators = mapSubFolder:GetDescendants()
                        for _, gen in pairs(generators) do
                            if gen:IsA("Model") and gen:FindFirstChild("Main") and gen.Name == "FakeGenerator" then
                                createFakeGeneratorESP(gen)
                            end
                        end
                    end
                end
            end
        end
        
        local mainConnection
        local mapFolder = workspace:FindFirstChild("Map")
        if mapFolder then
            local ingameFolder = mapFolder:FindFirstChild("Ingame")
            if ingameFolder then
                local mapSubFolder = ingameFolder:FindFirstChild("Map")
                if mapSubFolder then
                    mainConnection = mapSubFolder.DescendantAdded:Connect(function(v)
                        if v:IsA("Model") and v:FindFirstChild("Main") and v.Name == "FakeGenerator" then
                            createFakeGeneratorESP(v)
                        end
                    end)
                end
            end
        end
        
        if mainConnection then
            table.insert(_G.FakeGeneratorESP.Connections, mainConnection)
        end
        
        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
            lastScanTime = lastScanTime + deltaTime
            if lastScanTime >= scanInterval then
                lastScanTime = 0
                scanGenerators()
            end
            
            local gensToRemove = {}
            for gen, data in pairs(_G.FakeGeneratorESP.Data) do
                if not gen or not gen.Parent then
                    table.insert(gensToRemove, gen)
                end
            end
            
            for _, gen in ipairs(gensToRemove) do
                if _G.FakeGeneratorESP.Data[gen] then
                    if _G.FakeGeneratorESP.Data[gen].Highlight then 
                        _G.FakeGeneratorESP.Data[gen].Highlight:Destroy() 
                    end
                    if _G.FakeGeneratorESP.Data[gen].NameLabel then 
                        _G.FakeGeneratorESP.Data[gen].NameLabel:Destroy() 
                    end
                    if _G.FakeGeneratorESP.Data[gen].NameBillboard then 
                        _G.FakeGeneratorESP.Data[gen].NameBillboard:Destroy() 
                    end
                    _G.FakeGeneratorESP.Data[gen] = nil
                end
            end
        end)
        
        table.insert(_G.FakeGeneratorESP.Connections, heartbeatConnection)
        
        scanGenerators()
    end
})

-- 特殊电机ESP
Visual:AddToggle("NoliWarningESP", {
    Text = "绘制特殊发电机",
    Default = false,
    Callback = function(enabled)
        if not _G.NoliWarningESP then
            _G.NoliWarningESP = {
                Active = false,
                Data = {},
                Connections = {}
            }
        end
        
        if not enabled then
            if _G.NoliWarningESP.Active then
                for _, connection in pairs(_G.NoliWarningESP.Connections) do
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end
                
                for gen, data in pairs(_G.NoliWarningESP.Data) do
                    if type(data) == "table" then
                        if data.Highlight and data.Highlight.Parent then
                            data.Highlight:Destroy()
                        end
                        if data.Label and data.Label.Parent then
                            data.Label:Destroy()
                        end
                    end
                end
                
                _G.NoliWarningESP.Data = {}
                _G.NoliWarningESP.Connections = {}
                _G.NoliWarningESP.Active = false
            end
            return
        end
        
        if _G.NoliWarningESP.Active then
            return
        end
        
        _G.NoliWarningESP.Active = true
        
        local scanInterval = 1.0
        local lastScanTime = 0
        
        local function hasNoliWarning(gen)
            if string.find(gen.Name, "NoliWarningIncoming") then
                return true
            end
            
            for _, child in pairs(gen:GetDescendants()) do
                if (child:IsA("StringValue") or child:IsA("ObjectValue")) and 
                   string.find(tostring(child.Value), "NoliWarningIncoming") then
                    return true
                elseif child:IsA("BasePart") and string.find(child.Name, "NoliWarningIncoming") then
                    return true
                end
            end
            
            return false
        end
        
        local function createNoliWarningESP(gen)
            if not gen or not gen:FindFirstChild("Main") or _G.NoliWarningESP.Data[gen] then 
                return 
            end
            
            if not hasNoliWarning(gen) then
                return
            end
            
            local highlight = Instance.new("Highlight")
            highlight.Name = "NoliWarningHighlight"
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.Enabled = true
            highlight.OutlineColor = Color3.fromRGB(255, 0, 255)
            highlight.FillColor = Color3.fromRGB(255, 0, 255)
            highlight.FillTransparency = 0.7
            highlight.OutlineTransparency = 0
            highlight.Parent = gen
            
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "NoliWarningBillboard"
            billboard.Size = UDim2.new(6, 0, 2, 0)
            billboard.StudsOffset = Vector3.new(0, 3, 0)
            billboard.Adornee = gen.Main
            billboard.Parent = gen.Main
            billboard.AlwaysOnTop = true
            
            local label = Instance.new("TextLabel")
            label.Size = UDim2.new(1, 0, 1, 0)
            label.BackgroundTransparency = 1
            label.Text = "[Noli Will Tp]"
            label.TextColor3 = Color3.fromRGB(255, 0, 255)
            label.Font = Enum.Font.Arcade
            label.TextSize = 14
            label.TextStrokeTransparency = 0
            label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            label.Parent = billboard
            
            _G.NoliWarningESP.Data[gen] = {
                Highlight = highlight,
                Label = label,
                Billboard = billboard,
                LastCheck = os.time()
            }
            
            local destroyConnection
            destroyConnection = gen.Destroying:Connect(function()
                if _G.NoliWarningESP.Data[gen] then
                    if _G.NoliWarningESP.Data[gen].Highlight then 
                        _G.NoliWarningESP.Data[gen].Highlight:Destroy() 
                    end
                    if _G.NoliWarningESP.Data[gen].Label then 
                        _G.NoliWarningESP.Data[gen].Label:Destroy() 
                    end
                    if _G.NoliWarningESP.Data[gen].Billboard then 
                        _G.NoliWarningESP.Data[gen].Billboard:Destroy() 
                    end
                    _G.NoliWarningESP.Data[gen] = nil
                end
                if destroyConnection then
                    destroyConnection:Disconnect()
                end
            end)
            
            table.insert(_G.NoliWarningESP.Connections, destroyConnection)
        end
        
        local function scanGenerators()
            local generators = workspace:GetDescendants()
            for _, gen in pairs(generators) do
                if gen:IsA("Model") and gen:FindFirstChild("Main") and 
                   (gen.Name == "Generator" or gen.Name == "FakeGenerator") then
                    createNoliWarningESP(gen)
                end
            end
        end
        
        local function updateExistingGenerators()
            local gensToRemove = {}
            for gen, data in pairs(_G.NoliWarningESP.Data) do
                if not gen or not gen.Parent then
                    table.insert(gensToRemove, gen)
                else
                    if os.time() - data.LastCheck > 5 then
                        if not hasNoliWarning(gen) then
                            table.insert(gensToRemove, gen)
                        else
                            data.LastCheck = os.time()
                        end
                    end
                end
            end
            
            for _, gen in ipairs(gensToRemove) do
                if _G.NoliWarningESP.Data[gen] then
                    if _G.NoliWarningESP.Data[gen].Highlight then 
                        _G.NoliWarningESP.Data[gen].Highlight:Destroy() 
                    end
                    if _G.NoliWarningESP.Data[gen].Label then 
                        _G.NoliWarningESP.Data[gen].Label:Destroy() 
                    end
                    if _G.NoliWarningESP.Data[gen].Billboard then 
                        _G.NoliWarningESP.Data[gen].Billboard:Destroy() 
                    end
                    _G.NoliWarningESP.Data[gen] = nil
                end
            end
        end
        
        local mainConnection = workspace.DescendantAdded:Connect(function(v)
            if v:IsA("Model") and v:FindFirstChild("Main") and 
               (v.Name == "Generator" or v.Name == "FakeGenerator") then
                createNoliWarningESP(v)
            end
        end)
        
        table.insert(_G.NoliWarningESP.Connections, mainConnection)
        
        local heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
            lastScanTime = lastScanTime + deltaTime
            if lastScanTime >= scanInterval then
                lastScanTime = 0
                scanGenerators()
                updateExistingGenerators()
            end
        end)
        
        table.insert(_G.NoliWarningESP.Connections, heartbeatConnection)
        
        scanGenerators()
    end
})



local Visual = Tabs.Esp:AddRightGroupbox("物品绘制")

local LibESP = loadstring(game:HttpGet("https://raw.githubusercontent.com/ImamGV/Script/main/ESP"))()

Visual:AddToggle("EKE",{
    Text = "绘制杀手召唤物",
    Callback = function(v)
        if v then
            for _, v in ipairs(workspace:GetDescendants()) do
                if v:IsA("Model") and v.Name == "DeliveryRig" or v.Name == "Bunny" or v.Name == "Mafiaso1" or v.Name == "Mafiaso2" or v.Name == "Mafiaso3" then
                    LibESP:AddESP(v, "pizza deliveryman", Color3.fromRGB(255, 52, 179), 14, "Other_ESP")
                elseif v:IsA("Model") and v.Name == "1x1x1x1Zombie" then
                    LibESP:AddESP(v, "1x1x1x1 (zombie)", Color3.fromRGB(224, 102, 255), 14, "Other_ESP")
                end
            end
            OtherESP = workspace.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and v.Name == "PizzaDeliveryRig" or v.Name == "Bunny" or v.Name == "Mafiaso1" or v.Name == "Mafiaso2" or v.Name == "Mafiaso3" then
                    LibESP:AddESP(v, "pizza deliveryman", Color3.fromRGB(255, 52, 179), 14, "Other_ESP")
                elseif v:IsA("Model") and v.Name == "1x1x1x1Zombie" then
                    LibESP:AddESP(v, "1x1x1x1 (zombie)", Color3.fromRGB(224, 102, 255), 14, "Other_ESP")
                end
            end)
        else
            OtherESP:Disconnect()
            LibESP:Delete("Other_ESP")
        end
    end
})


-- 假007高亮系统
Visual:AddToggle("Fake007_Highlight", {
    Text = "绘制假007",
    Default = false,
    Callback = function(state)
        if state then
            -- 存储所有高亮对象的连接
            _G.Fake007HighlightedObjects = _G.Fake007HighlightedObjects or {}
            
            -- 高亮现有对象
            local function highlightFake007(obj)
                if obj.Name == "007n7" and not obj:FindFirstChild("Fake007_HL") then
                    -- 创建高亮效果
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "Fake007_HL"  -- 修正了这里的拼写错误
                    highlight.FillColor = Color3.fromRGB(0, 150, 255) -- 蓝色
                    highlight.OutlineColor = Color3.fromRGB(0, 100, 200)
                    highlight.FillTransparency = 0.3
                    highlight.OutlineTransparency = 0
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    
                    -- 添加名称标签（修改为蓝色文字+浅黑色描边）
                    local billboard = Instance.new("BillboardGui")
                    billboard.Name = "Fake007_Label"
                    billboard.Size = UDim2.new(5, 0, 1, 0)
                    billboard.StudsOffset = Vector3.new(0, 2, 0)
                    billboard.Adornee = obj:IsA("BasePart") and obj or obj:FindFirstChild("PrimaryPart") or nil
                    billboard.AlwaysOnTop = true
                    
                    local label = Instance.new("TextLabel")
                    label.Text = "假007n7"
                    label.TextColor3 = Color3.fromRGB(0, 150, 255) -- 蓝色文字
                    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0) -- 黑色描边
                    label.TextStrokeTransparency = 0.5 -- 半透明描边（0.5表示50%透明度）
                    label.TextSize = 14
                    label.Font = Enum.Font.SourceSansBold
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.Parent = billboard
                    
                    highlight.Parent = obj
                    billboard.Parent = obj
                    
                    -- 监听对象移除
                    _G.Fake007HighlightedObjects[obj] = obj.AncestryChanged:Connect(function(_, parent)
                        if not parent then
                            if highlight and highlight.Parent then
                                highlight:Destroy()
                            end
                            if billboard and billboard.Parent then
                                billboard:Destroy()
                            end
                            if _G.Fake007HighlightedObjects[obj] then
                                _G.Fake007HighlightedObjects[obj]:Disconnect()
                                _G.Fake007HighlightedObjects[obj] = nil
                            end
                        end
                    end)
                end
            end

            -- 扫描Map.Ingame目录
            local mapIngame = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
            if mapIngame then
                for _, obj in ipairs(mapIngame:GetDescendants()) do
                    highlightFake007(obj)
                end
            end

            -- 监听新增对象
            _G.Fake007Connection = workspace.DescendantAdded:Connect(function(obj)
                if obj:IsDescendantOf(mapIngame) and obj.Name == "007n7" then
                    highlightFake007(obj)
                end
            end)
        else
            -- 禁用时清理
            if _G.Fake007Connection then
                _G.Fake007Connection:Disconnect()
            end
            
            -- 清理所有高亮对象
            for obj, connection in pairs(_G.Fake007HighlightedObjects or {}) do
                if connection then
                    connection:Disconnect()
                end
                if obj:FindFirstChild("Fake007_HL") then
                    obj.Fake007_HL:Destroy()
                end
                if obj:FindFirstChild("Fake007_Label") then
                    obj.Fake007_Label:Destroy()
                end
            end
            _G.Fake007HighlightedObjects = {}
        end
    end
})

Visual:AddToggle("TWE", {
    Text = "绘制塔夫拌线",
    Default = false,
    Callback = function(state)
        if state then
            -- 存储所有高亮对象的连接
            _G.TWE_HighlightedObjects = _G.TWE_HighlightedObjects or {}
            
            -- 高亮现有绊线
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj.Name:match("TaphTripwire") and not obj:FindFirstChild("TWE_Highlight") then
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "TWE_Highlight"
                    highlight.FillColor = Color3.fromRGB(102, 0, 153) -- 深紫色
                    highlight.OutlineColor = Color3.fromRGB(102, 0, 153)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Parent = obj
                    
                    -- 监听对象移除
                    _G.TWE_HighlightedObjects[obj] = obj.AncestryChanged:Connect(function(_, parent)
                        if not parent and highlight and highlight.Parent then
                            highlight:Destroy()
                            if _G.TWE_HighlightedObjects[obj] then
                                _G.TWE_HighlightedObjects[obj]:Disconnect()
                                _G.TWE_HighlightedObjects[obj] = nil
                            end
                        end
                    end)
                end
            end

            -- 监听新增绊线
            _G.TWE_Connection = workspace.DescendantAdded:Connect(function(obj)
                if obj.Name:match("TaphTripwire") and not obj:FindFirstChild("TWE_Highlight") then
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "TWE_Highlight"
                    highlight.FillColor = Color3.fromRGB(102, 0, 153)
                    highlight.OutlineColor = Color3.fromRGB(102, 0, 153)
                    highlight.FillTransparency = 0.5
                    highlight.OutlineTransparency = 0
                    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    highlight.Parent = obj
                    
                    -- 监听对象移除
                    _G.TWE_HighlightedObjects[obj] = obj.AncestryChanged:Connect(function(_, parent)
                        if not parent and highlight and highlight.Parent then
                            highlight:Destroy()
                            if _G.TWE_HighlightedObjects[obj] then
                                _G.TWE_HighlightedObjects[obj]:Disconnect()
                                _G.TWE_HighlightedObjects[obj] = nil
                            end
                        end
                    end)
                end
            end)
        else
            -- 禁用时清除所有高亮和连接
            if _G.TWE_Connection then
                _G.TWE_Connection:Disconnect()
            end
            
            -- 清理所有高亮对象
            for obj, connection in pairs(_G.TWE_HighlightedObjects or {}) do
                if connection then
                    connection:Disconnect()
                end
                if obj:FindFirstChild("TWE_Highlight") then
                    obj.TWE_Highlight:Destroy()
                end
            end
            _G.TWE_HighlightedObjects = {}
        end
    end
})


Visual:AddToggle("ShadowDetector", {
    Text = "绘制约翰陷阱",
    Default = false,
    Callback = function(Value)
        -- Define all variables and functions inside the callback to keep them contained
        local currentShadows = {}
        local checkingConnection = nil
        local isRunning = false
        local scriptConnection = nil

        -- Recursive function to find all Shadow objects
        local function findAllShadowsInFolder(folder)
            local shadows = {}
            for _, child in ipairs(folder:GetChildren()) do
                if child.Name == "Shadow" then
                    table.insert(shadows, child)
                elseif child:IsA("Folder") or child:IsA("Model") then
                    local foundShadows = findAllShadowsInFolder(child)
                    for _, foundShadow in ipairs(foundShadows) do
                        table.insert(shadows, foundShadow)
                    end
                end
            end
            return shadows
        end

        -- Create marker for a single Shadow
        local function createShadowMarker(shadow)
            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            local function getObjectSize(obj)
                if obj:IsA("BasePart") then
                    return obj.Size
                elseif obj:IsA("Model") and obj.PrimaryPart then
                    local cf = obj:GetBoundingBox()
                    return (cf[2] - cf[1]).Magnitude
                else
                    return Vector3.new(5, 5, 5)
                end
            end
            
            local objectSize = getObjectSize(shadow)
            
            local highlight = Instance.new("Highlight")
            highlight.Name = "ShadowRangeIndicator"
            highlight.FillColor = Color3.fromRGB(255, 0, 0)
            highlight.FillTransparency = 0.8
            highlight.OutlineColor = Color3.fromRGB(255, 100, 100)
            highlight.OutlineTransparency = 0.5
            highlight.Parent = shadow
            
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "ShadowNameDisplay"
            billboard.AlwaysOnTop = true
            billboard.Size = UDim2.new(0, 180, 0, 60)
            billboard.StudsOffset = Vector3.new(0, objectSize.Y/2 + 2, 0)
            billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
            
            local textLabel = Instance.new("TextLabel")
            textLabel.Name = "TrapLabel"
            textLabel.Text = "TRAP"
            textLabel.Size = UDim2.new(1, 0, 0.5, 0)
            textLabel.Position = UDim2.new(0, 0, 0, 0)
            textLabel.Font = Enum.Font.Arcade
            textLabel.TextSize = 18
            textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.TextStrokeTransparency = 0
            textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            textLabel.TextXAlignment = Enum.TextXAlignment.Center
            textLabel.TextYAlignment = Enum.TextYAlignment.Center
            
            local distanceLabel = Instance.new("TextLabel")
            distanceLabel.Name = "DistanceLabel"
            distanceLabel.Text = "Distance: Calculating..."
            distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
            distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
            distanceLabel.Font = Enum.Font.Arcade
            distanceLabel.TextSize = 14
            distanceLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
            distanceLabel.BackgroundTransparency = 1
            distanceLabel.TextStrokeTransparency = 0
            distanceLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            distanceLabel.TextXAlignment = Enum.TextXAlignment.Center
            distanceLabel.TextYAlignment = Enum.TextYAlignment.Center
            
            textLabel.Parent = billboard
            distanceLabel.Parent = billboard
            billboard.Parent = shadow
            
            if shadow:IsA("BasePart") then
                local boxHandleAdornment = Instance.new("BoxHandleAdornment")
                boxHandleAdornment.Name = "SizeIndicator"
                boxHandleAdornment.Adornee = shadow
                boxHandleAdornment.AlwaysOnTop = true
                boxHandleAdornment.Size = shadow.Size
                boxHandleAdornment.Transparency = 0.7
                boxHandleAdornment.Color3 = Color3.fromRGB(255, 50, 50)
                boxHandleAdornment.ZIndex = 10
                boxHandleAdornment.Parent = shadow
            end
            
            local heartbeatConnection
            heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not shadow or not shadow.Parent then 
                    if heartbeatConnection then
                        heartbeatConnection:Disconnect()
                        heartbeatConnection = nil
                    end
                    return 
                end
                if not humanoidRootPart or not humanoidRootPart.Parent then return end
                
                local distance = (humanoidRootPart.Position - shadow.Position).Magnitude
                distanceLabel.Text = string.format("Distance: %.1f m", distance)
                
                local baseScale = math.clamp(40 / math.max(1, distance), 0.4, 1.8)
                textLabel.TextSize = 18 * baseScale
                distanceLabel.TextSize = 14 * baseScale
                
                local overallTransparency = math.clamp(distance / 80, 0.1, 0.4)
                local strokeTransparency = overallTransparency * 0.1
                textLabel.TextStrokeTransparency = strokeTransparency
                distanceLabel.TextStrokeTransparency = strokeTransparency
                highlight.FillTransparency = math.clamp(distance/70, 0.3, 0.8)
            end)
            
            currentShadows[shadow] = {
                heartbeat = heartbeatConnection,
                marker = {
                    highlight = highlight,
                    billboard = billboard,
                    textLabel = textLabel,
                    distanceLabel = distanceLabel,
                    boxHandle = shadow:IsA("BasePart") and shadow:FindFirstChild("SizeIndicator")
                }
            }
        end

        -- Remove marker for a single Shadow
        local function removeShadowMarker(shadow)
            local markerData = currentShadows[shadow]
            if markerData then
                if markerData.heartbeat then
                    markerData.heartbeat:Disconnect()
                end
                
                if markerData.marker then
                    if markerData.marker.highlight and markerData.marker.highlight.Parent then
                        markerData.marker.highlight:Destroy()
                    end
                    if markerData.marker.billboard and markerData.marker.billboard.Parent then
                        markerData.marker.billboard:Destroy()
                    end
                    if markerData.marker.boxHandle and markerData.marker.boxHandle.Parent then
                        markerData.marker.boxHandle:Destroy()
                    end
                end
                
                currentShadows[shadow] = nil
            end
        end

        -- Check and update Shadow markers
        local function checkAndUpdateShadows()
            local allFolders = {workspace.Map.Ingame}
            local foundShadows = {}
            
            for _, folder in ipairs(allFolders) do
                if folder and (folder:IsA("Folder") or folder:IsA("Model")) then
                    local shadowsInFolder = findAllShadowsInFolder(folder)
                    for _, shadow in ipairs(shadowsInFolder) do
                        table.insert(foundShadows, shadow)
                    end
                end
            end
            
            for _, shadow in ipairs(foundShadows) do
                if not currentShadows[shadow] then
                    createShadowMarker(shadow)
                end
            end
            
            local shadowsToRemove = {}
            for shadow, _ in pairs(currentShadows) do
                local stillExists = false
                for _, foundShadow in ipairs(foundShadows) do
                    if shadow == foundShadow then
                        stillExists = true
                        break
                    end
                end
                
                if not stillExists then
                    table.insert(shadowsToRemove, shadow)
                end
            end
            
            for _, shadow in ipairs(shadowsToRemove) do
                removeShadowMarker(shadow)
            end
        end

        -- Start the detection system
        local function startShadowChecking()
            if isRunning then return end
            isRunning = true
            
            checkAndUpdateShadows()
            
            checkingConnection = game:GetService("RunService").Heartbeat:Connect(function()
                -- Empty connection just to keep the script alive
            end)
            
            scriptConnection = game:GetService("RunService").Stepped:Connect(function()
                local success, _ = pcall(function()
                    local test = script.Name
                end)
                
                if not success then
                    stopShadowChecking()
                    if scriptConnection then
                        scriptConnection:Disconnect()
                        scriptConnection = nil
                    end
                end
            end)
            
            task.spawn(function()
                while isRunning do
                    checkAndUpdateShadows()
                    task.wait(2)
                end
            end)
        end

        -- Stop the detection system
        local function stopShadowChecking()
            if not isRunning then return end
            isRunning = false
            
            if checkingConnection then
                checkingConnection:Disconnect()
                checkingConnection = nil
            end
            
            if scriptConnection then
                scriptConnection:Disconnect()
                scriptConnection = nil
            end
            
            for shadow, _ in pairs(currentShadows) do
                removeShadowMarker(shadow)
            end
            
            currentShadows = {}
        end

        -- Handle the toggle state
        if Value then
            startShadowChecking()
        else
            stopShadowChecking()
        end
    end
})

Visual:AddToggle("ST",{
Text = "绘制塔夫空间炸弹",
Callback = function(v)
if v then
for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "SubspaceTripmine" and not v:FindFirstChild("SubspaceTripmine_ESP") then
LibESP:AddESP(v, "", Color3.fromRGB(255, 0, 255), 14, "SubspaceTripmine_ESP")
end
end
SubspaceTripmineESP = workspace.DescendantAdded:Connect(function(v)
if v:IsA("Model") and v.Name == "SubspaceTripmine" and not v:FindFirstChild("SubspaceTripmine_ESP") then
LibESP:AddESP(v, "", Color3.fromRGB(255, 0, 255), 14, "SubspaceTripmine_ESP")
end
end)
else
SubspaceTripmineESP:Disconnect()
LibESP:Delete("SubspaceTripmine_ESP")
end
end})
Visual:AddToggle("ME",{
Text = "医疗包绘制",
Callback = function(v)
if v then
for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "Medkit" and not v:FindFirstChild("Medkit_ESP") then
LibESP:AddESP(v, "Medkit", Color3.fromRGB(187, 255, 255), 14, "Medkit_ESP")
end
end
MedkitESP = workspace.DescendantAdded:Connect(function(v)
if v:IsA("Model") and v.Name == "Medkit" and not v:FindFirstChild("Medkit_ESP") then
LibESP:AddESP(v, "Medkit", Color3.fromRGB(187, 255, 255), 14, "Medkit_ESP")
end
end)
else
Medkit:Disconnect()
LibESP:Delete("Medkit_ESP")
end
end})
Visual:AddToggle("BCE",{
Text = "可乐绘制",
Callback = function(v)
if v then
for _, v in ipairs(workspace:GetDescendants()) do
if v:IsA("Model") and v.Name == "BloxyCola" and not v:FindFirstChild("BloxyCola_ESP") then
LibESP:AddESP(v, "Bloxy Cola", Color3.fromRGB(131, 111, 255), 14, "BloxyCola_ESP")
end
end
ColaESP = workspace.DescendantAdded:Connect(function(v)
if v:IsA("Model") and v.Name == "BloxyCola" and not v:FindFirstChild("BloxyCola_ESP") then
LibESP:AddESP(v, "Bloxy Cola", Color3.fromRGB(131, 111, 255), 14, "BloxyCola_ESP")
end
end)
else
ColaESP:Disconnect()
LibESP:Delete("BloxyCola_ESP")
end
end})


local LeftGroupBox = Tabs.Aimbot:AddRightGroupbox('1x4 远程预判')
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer
local PredictionAim = {
	Enabled = false,
	Prediction = 4,
	MaxDistance = 500, -- 新增：最大自瞄距离
	Duration = 1.7,
	Targets = { "Guest1337", "007n7", "Builderman", "Chance", "Dusekkar", "Elliot", "Noob", "Shedletsky", "Taph", "TwoTime" },
	TrackedAnimations = {
		["131430497821198"] = true,
		["119181003138006"] = true,
		["70447634862911"] = true,
		["93491748129367"] = true
	},
	Humanoid = nil,
	HRP = nil,
	LastTriggerTime = 1,
	IsAiming = false,
	OriginalState = nil
}

local function CreateUI()
	LeftGroupBox:AddToggle("AimToggle", {
		Text = "Aimbot",
		Default = false,
		Callback = function(Value)
			PredictionAim.Enabled = Value
		end,
	})
	
	-- 添加距离滑块（放在前面）
	LeftGroupBox:AddSlider("DistanceSlider", {
		Text = "预判瞄准",
		Default = 100,
		Min = 1,
		Max = 500,
		Rounding = 1,
		Callback = function(Value)
			PredictionAim.MaxDistance = Value
		end,
	})
	
	LeftGroupBox:AddSlider("PredictionSlider", {
		Text = "预判强度",
		Default = 4,
		Min = 0,
		Max = 15,
		Rounding = 1,
		Callback = function(Value)
			PredictionAim.Prediction = Value
		end,
	})
end

-- 修改：获取最近的幸存者
local function getNearestTarget()
	local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
	if not killersFolder then return nil end
	
	local nearestTarget = nil
	local nearestDistance = PredictionAim.MaxDistance
	local myPosition = PredictionAim.HRP.Position
	
	for _, name in ipairs(PredictionAim.Targets) do
		local target = killersFolder:FindFirstChild(name)
		if target and target:FindFirstChild("HumanoidRootPart") then
			local distance = (target.HumanoidRootPart.Position - myPosition).Magnitude
			if distance <= nearestDistance then
				nearestDistance = distance
				nearestTarget = target.HumanoidRootPart
			end
		end
	end
	
	return nearestTarget
end

local function getPlayingAnimationIds()
	local ids = {}
	if PredictionAim.Humanoid then
		for _, track in ipairs(PredictionAim.Humanoid:GetPlayingAnimationTracks()) do
			if track.Animation and track.Animation.AnimationId then
				local id = track.Animation.AnimationId:match("%d+")
				if id then ids[id] = true end
			end
		end
	end
	return ids
end

local function setupCharacter(char)
	PredictionAim.Humanoid = char:WaitForChild("Humanoid")
	PredictionAim.HRP = char:WaitForChild("HumanoidRootPart")
end

local function OnRenderStep()
	if not PredictionAim.Enabled or not PredictionAim.Humanoid or not PredictionAim.HRP then return end
	local playing = getPlayingAnimationIds()
	local triggered = false
	for id in pairs(PredictionAim.TrackedAnimations) do
		if playing[id] then triggered = true; break end
	end

	if triggered then
		PredictionAim.LastTriggerTime = tick()
		PredictionAim.IsAiming = true
	end

	if PredictionAim.IsAiming and tick() - PredictionAim.LastTriggerTime <= PredictionAim.Duration then
		if not PredictionAim.OriginalState then
			PredictionAim.OriginalState = {
				WalkSpeed = PredictionAim.Humanoid.WalkSpeed,
				JumpPower = PredictionAim.Humanoid.JumpPower,
				AutoRotate = PredictionAim.Humanoid.AutoRotate
			}
			PredictionAim.Humanoid.AutoRotate = false
			PredictionAim.HRP.AssemblyAngularVelocity = Vector3.zero
		end
		
		-- 修改：使用新的获取目标函数
		local targetHRP = getNearestTarget()
		if targetHRP then
			local predictedPos = targetHRP.Position + (targetHRP.Velocity * PredictionAim.Prediction * 0.1)
			local direction = (predictedPos - PredictionAim.HRP.Position).Unit
			local yRot = math.atan2(-direction.X, -direction.Z)
			PredictionAim.HRP.CFrame = CFrame.new(PredictionAim.HRP.Position) * CFrame.Angles(0, yRot, 0)
		end
	elseif PredictionAim.IsAiming then
		PredictionAim.IsAiming = false
		if PredictionAim.OriginalState then
			PredictionAim.Humanoid.WalkSpeed = PredictionAim.OriginalState.WalkSpeed
			PredictionAim.Humanoid.JumpPower = PredictionAim.OriginalState.JumpPower
			PredictionAim.Humanoid.AutoRotate = PredictionAim.OriginalState.AutoRotate
			PredictionAim.OriginalState = nil
		end
	end
end

if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(setupCharacter)
CreateUI()
RunService.RenderStepped:Connect(OnRenderStep)





local LeftGroupBox = Tabs.Aimbot:AddLeftGroupbox('其他')
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer

do
	local Backstab = {
		Enabled = false,
		Mode = "Behind",
		Range = 4,
		Cooldown = false,
		LastTarget = nil,
		KillerNames = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" },
		DaggerRemote = game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"),
		KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
	}

	local function CreateUI()
		LeftGroupBox:AddToggle("BackstabToggle", {
			Text = "自动背刺[Two Time]",
			Default = false,
			Callback = function(Value)
				Backstab.Enabled = Value
			end,
		})

		LeftGroupBox:AddDropdown("BackstabModeDropdown", {
			Values = { "Behind", "Around" },
			Default = 1,
			Multi = false,
			Text = "模式",
			Callback = function(Value)
				if Value == "Behind" then
					Backstab.Mode = "Behind"
				elseif Value == "Around" then
					Backstab.Mode = "Around"
				end
			end,
		})

		LeftGroupBox:AddSlider("BackstabRangeSlider", {
			Text = "距离",
			Default = 4,
			Min = 1,
			Max = 20,
			Rounding = 0,
			Callback = function(Value)
				Backstab.Range = Value
			end,
		})
	end

	local function isBehindTarget(hrp, targetHRP)
		if not (hrp and targetHRP and hrp.Parent and targetHRP.Parent) then return false end
		local distance = (hrp.Position - targetHRP.Position).Magnitude
		if distance > Backstab.Range then return false end

		if Backstab.Mode == "Around" then
			return true
		else
			local direction = -targetHRP.CFrame.LookVector
			local toPlayer = (hrp.Position - targetHRP.Position)
			return toPlayer:Dot(direction) > 0.5
		end
	end

	local function OnHeartbeat()
		if not Backstab.Enabled or Backstab.Cooldown then return end
		local char = LocalPlayer.Character
		if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
		local hrp = char.HumanoidRootPart

		for _, name in ipairs(Backstab.KillerNames) do
			local killer = Backstab.KillersFolder:FindFirstChild(name)
			if killer and killer:FindFirstChild("HumanoidRootPart") then
				local kHRP = killer.HumanoidRootPart
				if isBehindTarget(hrp, kHRP) and killer ~= Backstab.LastTarget then
					Backstab.Cooldown = true
					Backstab.LastTarget = killer
					hrp.CFrame = CFrame.new(kHRP.Position - kHRP.CFrame.LookVector, kHRP.Position)
					Backstab.DaggerRemote:FireServer("UseActorAbility", "Dagger")
					task.delay(1, function()
						Backstab.LastTarget = nil
						Backstab.Cooldown = false
					end)
					break
				end
			end
		end
	end

	CreateUI()
	RunService.Heartbeat:Connect(OnHeartbeat)
end

do
	local PredictionAim = {
		Enabled = false,
		Prediction = 4,
		Duration = 1.7,
		Targets = { "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" },
		TrackedAnimations = {
			["103601716322988"] = true, ["133491532453922"] = true, ["86371356500204"] = true,
			["76649505662612"] = true, ["81698196845041"] = true
		},
		Humanoid = nil,
		HRP = nil,
		LastTriggerTime = 0,
		IsAiming = false,
		OriginalState = nil
	}

	local function CreateUI()
		LeftGroupBox:AddToggle("AimToggle", {
			Text = "预判瞄准[Chance]",
			Default = false,
			Callback = function(Value)
				PredictionAim.Enabled = Value
			end,
		})
		LeftGroupBox:AddSlider("PredictionSlider", {
			Text = "预判系数",
			Default = 4,
			Min = 0,
			Max = 15,
			Rounding = 1,
			Callback = function(Value)
				PredictionAim.Prediction = Value
			end,
		})
	end

	local function getValidTarget()
		local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
		if killersFolder then
			for _, name in ipairs(PredictionAim.Targets) do
				local target = killersFolder:FindFirstChild(name)
				if target and target:FindFirstChild("HumanoidRootPart") then
					return target.HumanoidRootPart
				end
			end
		end
		return nil
	end

	local function getPlayingAnimationIds()
		local ids = {}
		if PredictionAim.Humanoid then
			for _, track in ipairs(PredictionAim.Humanoid:GetPlayingAnimationTracks()) do
				if track.Animation and track.Animation.AnimationId then
					local id = track.Animation.AnimationId:match("%d+")
					if id then ids[id] = true end
				end
			end
		end
		return ids
	end

	local function setupCharacter(char)
		PredictionAim.Humanoid = char:WaitForChild("Humanoid")
		PredictionAim.HRP = char:WaitForChild("HumanoidRootPart")
	end

	local function OnRenderStep()
		if not PredictionAim.Enabled or not PredictionAim.Humanoid or not PredictionAim.HRP then return end
		local playing = getPlayingAnimationIds()
		local triggered = false
		for id in pairs(PredictionAim.TrackedAnimations) do
			if playing[id] then triggered = true; break end
		end

		if triggered then
			PredictionAim.LastTriggerTime = tick()
			PredictionAim.IsAiming = true
		end

		if PredictionAim.IsAiming and tick() - PredictionAim.LastTriggerTime <= PredictionAim.Duration then
			if not PredictionAim.OriginalState then
				PredictionAim.OriginalState = {
					WalkSpeed = PredictionAim.Humanoid.WalkSpeed,
					JumpPower = PredictionAim.Humanoid.JumpPower,
					AutoRotate = PredictionAim.Humanoid.AutoRotate
				}
				PredictionAim.Humanoid.AutoRotate = false
				PredictionAim.HRP.AssemblyAngularVelocity = Vector3.zero
			end
			local targetHRP = getValidTarget()
			if targetHRP then
				local predictedPos = targetHRP.Position + (targetHRP.CFrame.LookVector * PredictionAim.Prediction)
				local direction = (predictedPos - PredictionAim.HRP.Position).Unit
				local yRot = math.atan2(-direction.X, -direction.Z)
				PredictionAim.HRP.CFrame = CFrame.new(PredictionAim.HRP.Position) * CFrame.Angles(0, yRot, 0)
			end
		elseif PredictionAim.IsAiming then
			PredictionAim.IsAiming = false
			if PredictionAim.OriginalState then
				PredictionAim.Humanoid.WalkSpeed = PredictionAim.OriginalState.WalkSpeed
				PredictionAim.Humanoid.JumpPower = PredictionAim.OriginalState.JumpPower
				PredictionAim.Humanoid.AutoRotate = PredictionAim.OriginalState.AutoRotate
				PredictionAim.OriginalState = nil
			end
		end
	end

	if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
	LocalPlayer.CharacterAdded:Connect(setupCharacter)
	CreateUI()
	RunService.RenderStepped:Connect(OnRenderStep)
end


local Size = 5
local speed = 1
local player = game:GetService("Players").LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local rootPart = char:WaitForChild("HumanoidRootPart")
local humanoid = char:WaitForChild("Humanoid")

-- 为每个自瞄功能创建独立的最大距离变量

local twoTimeMaxDistance = 50
local shedletskyMaxDistance = 50
local johnMaxDistance = 50

-- 创建UI
local SB = Tabs.Aimbot:AddLeftGroupbox('幸存者自瞄[平滑]')

-- 双持者自瞄距离滑块
SB:AddSlider('TwoTimeDistance', {
    Text = '双持者自瞄距离',
    Default = 50,
    Min = 10,
    Max = 150,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        twoTimeMaxDistance = value
    end
})

-- 谢德利茨基自瞄距离滑块
SB:AddSlider('ShedletskyDistance', {
    Text = '谢德利茨基自瞄距离',
    Default = 50,
    Min = 10,
    Max = 150,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        shedletskyMaxDistance = value
    end
})

local function TWO(state)
    local TWOsounds = {
        "rbxassetid://86710781315432",
        "rbxassetid://99820161736138"
    }
    
    TWOTIME = state

    if game:GetService("Players").LocalPlayer.Character.Name ~= "TwoTime" and state then
        Library:Notify("你的角色不是双持者，无效", nil, 4590657391)
        return 
    end

    if state then
        TWOloop = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.ChildAdded:Connect(function(child)
            if not TWOTIME then return end
            for _, v in pairs(TWOsounds) do
                if child.Name == v then
                    local survivors = {}
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game:GetService("Players").LocalPlayer then
                            local character = player.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                table.insert(survivors, character)
                            end
                        end
                    end

                    local nearestSurvivor = nil
                    local shortestDistance = math.huge  
                    
                    for _, survivor in pairs(survivors) do
                        local survivorHRP = survivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if playerHRP then
                            local distance = (survivorHRP.Position - playerHRP.Position).Magnitude
                            if distance < shortestDistance and distance <= twoTimeMaxDistance then
                                shortestDistance = distance
                                nearestSurvivor = survivor
                            end
                        end
                    end
                    
                    if nearestSurvivor then
                        local nearestHRP = nearestSurvivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if playerHRP then
                            local direction = (nearestHRP.Position - playerHRP.Position).Unit
                            local num = 1
                            local maxIterations = 100 
                            
                            if child.Name == "rbxassetid://79782181585087" then
                                maxIterations = 220  
                            end

                            while num <= maxIterations do
                                task.wait(0.01)
                                num = num + 1
                                workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, nearestHRP.Position)
                                playerHRP.CFrame = CFrame.lookAt(playerHRP.Position, Vector3.new(nearestHRP.Position.X, nearestHRP.Position.Y, nearestHRP.Position.Z))  
                            end
                        end
                    end
                end
            end
        end)
    else
        if TWOloop then
            TWOloop:Disconnect()
            TWOloop = nil
        end
    end
end

local function shedletskyAimbot(state)
    shedaim = state
    if state then
        if game:GetService("Players").LocalPlayer.Character.Name ~= "Shedletsky" then
            Library:Notify("我认为你扮演的角色不是谢德利茨基，无效", nil, 4590657391)
            return
        end
        
        shedloop = game:GetService("Players").LocalPlayer.Character.Sword.ChildAdded:Connect(function(child)
            if not shedaim then return end
            if child:IsA("Sound") then 
                local FAN = child.Name
                if FAN == "rbxassetid://12222225" or FAN == "83851356262523" then 
                    local killersFolder = game.Workspace.Players:FindFirstChild("Killers")
                    if killersFolder then 
                        local killer = killersFolder:FindFirstChildOfClass("Model")
                        if killer and killer:FindFirstChild("HumanoidRootPart") then 
                            local killerHRP = killer.HumanoidRootPart
                            local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                            if playerHRP then 
                                local distance = (killerHRP.Position - playerHRP.Position).Magnitude
                                if distance <= shedletskyMaxDistance then
                                    local num = 1
                                    local maxIterations = 100
                                    while num <= maxIterations do
                                        task.wait(0.01)
                                        num = num + 1
                                        workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, killerHRP.Position)
                                        playerHRP.CFrame = CFrame.lookAt(playerHRP.Position, killerHRP.Position)
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    else
        if shedloop then 
            shedloop:Disconnect()
            shedloop = nil
        end
    end
end

-- 杀手UI
local SC = Tabs.Aimbot:AddRightGroupbox('杀手自瞄[平滑]')




-- 约翰自瞄距离滑块
SC:AddSlider('JohnDistance', {
    Text = '约翰自瞄距离',
    Default = 50,
    Min = 10,
    Max = 150,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        johnMaxDistance = value
    end
})





local function johnaimbot(state)
    local johnaimbotsounds = {
        "rbxassetid://109525294317144"
    }
    
    johnaim = state
    if game:GetService("Players").LocalPlayer.Character.Name ~= "JohnDoe" and state then
        Library:Notify("Incorrect role，invalid", nil, 4590657391)
        return 
    end
    
    if state then
        johnloop = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.ChildAdded:Connect(function(child)
            if not johnaim then return end
            for _, v in pairs(johnaimbotsounds) do
                if child.Name == v then
                    local survivors = {}
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game:GetService("Players").LocalPlayer then
                            local character = player.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                table.insert(survivors, character)
                            end
                        end
                    end

                    local nearestSurvivor = nil
                    local shortestDistance = math.huge  
                    
                    for _, survivor in pairs(survivors) do
                        local survivorHRP = survivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if playerHRP then
                            local distance = (survivorHRP.Position - playerHRP.Position).Magnitude
                            if distance < shortestDistance and distance <= johnMaxDistance then
                                shortestDistance = distance
                                nearestSurvivor = survivor
                            end
                        end
                    end
                    
                    if nearestSurvivor then
                        local nearestHRP = nearestSurvivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local maxIterations = 330
                        if playerHRP then
                            local direction = (nearestHRP.Position - playerHRP.Position).Unit
                            local num = 1
                            
                            while num <= maxIterations do
                                task.wait(0.01)
                                num = num + 1
                                workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, nearestHRP.Position)
                                playerHRP.CFrame = CFrame.lookAt(playerHRP.Position, Vector3.new(nearestHRP.Position.X, nearestHRP.Position.Y, nearestHRP.Position.Z))
                            end
                        end
                    end
                end
            end
        end)
    else
        if johnloop then
            johnloop:Disconnect()
            johnloop = nil
        end
    end
end





SB:AddToggle('MyToggle', {
    Text = '双持者自瞄距离',
    Default = false,
    Tooltip = 'Aim',
    Callback = TWO
})

SB:AddToggle('MyToggle', {
    Text = '谢德利茨基自瞄距离 ',
    Default = false,
    Tooltip = 'Aim',
    Callback = shedletskyAimbot
})


SC:AddToggle('MyToggle', {
    Text = '约翰多自瞄',
    Default = false,
    Tooltip = 'Aim',
    Callback = johnaimbot
})


local SpecialAimbot = Tabs.Aimbot:AddLeftGroupbox("自瞄(静默)")

-- 默认距离设置
local defaultAimDistance = 100
local aimDistanceSettings = {
    CSA = defaultAimDistance,
    SSA = defaultAimDistance,
    GAA = defaultAimDistance
}

-- 平滑度和锁定时间设置
local aimSmoothnessSettings = {
    CSA = 10,
    SSA = 10,
    GAA = 10
}

local aimDurationSettings = {
    CSA = 100, -- 默认100帧 (约1秒，假设60FPS)
    SSA = 100,
    GAA = 100
}

-- 添加距离调节滑块
SpecialAimbot:AddSlider("CSA_Distance", {
    Text = "机会自瞄距离",
    Default = defaultAimDistance,
    Min = 10,
    Max = 500,
    Rounding = 1,
    Callback = function(value)
        aimDistanceSettings.CSA = value
    end
})

SpecialAimbot:AddSlider("SSA_Distance", {
    Text = "谢迪自瞄距离",
    Default = defaultAimDistance,
    Min = 10,
    Max = 500,
    Rounding = 1,
    Callback = function(value)
        aimDistanceSettings.SSA = value
    end
})

SpecialAimbot:AddSlider("GAA_Distance", {
    Text = "访客自瞄距离",
    Default = defaultAimDistance,
    Min = 10,
    Max = 500,
    Rounding = 1,
    Callback = function(value)
        aimDistanceSettings.GAA = value
    end
})

-- 添加平滑度调节滑块
SpecialAimbot:AddSlider("CSA_Smoothness", {
    Text = "钱斯平滑度",
    Default = 10,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(value)
        aimSmoothnessSettings.CSA = value
    end
})

SpecialAimbot:AddSlider("SSA_Smoothness", {
    Text = "谢迪平滑度",
    Default = 10,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(value)
        aimSmoothnessSettings.SSA = value
    end
})

SpecialAimbot:AddSlider("GAA_Smoothness", {
    Text = "访客平滑度",
    Default = 10,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(value)
        aimSmoothnessSettings.GAA = value
    end
})

-- 平滑转向函数
local function SmoothLookAt(currentCF, targetPos, smoothness)
    local currentLook = currentCF.LookVector
    local targetLook = (targetPos - currentCF.Position).Unit
    local newLook = currentLook:Lerp(targetLook, 1/smoothness)
    return CFrame.lookAt(currentCF.Position, currentCF.Position + newLook)
end

function AimShootChance(value)
    local aimshootchance = value
    if value then
        local chanceaimbotsounds = {
            "rbxassetid://201858045",
            "rbxassetid://139012439429121"
        }
        aimshootchance = game.Players.LocalPlayer.Character.HumanoidRootPart.ChildAdded:Connect(function(child)
            if not aimshootchance then return end
            for _, v in ipairs(chanceaimbotsounds) do
                if child.Name == v then
                    local targetkiller = game.Workspace.Players:FindFirstChild("Killers"):FindFirstChildOfClass("Model")
                    if targetkiller and targetkiller:FindFirstChild("HumanoidRootPart") then
                        if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (targetkiller.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                            if distance <= aimDistanceSettings.CSA then
                                local number = 1
                                local smoothness = aimSmoothnessSettings.CSA
                                local duration = aimDurationSettings.CSA
                                local connection
                                connection = game:GetService("RunService").RenderStepped:Connect(function()
                                    if number <= duration then
                                        task.wait(0.01)
                                        number = number + 1
                                        local currentCF = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                                        local targetPos = targetkiller.HumanoidRootPart.Position
                                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = SmoothLookAt(currentCF, targetPos, smoothness)
                                    else
                                        connection:Disconnect()
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end)
    else
        if aimshootchance then
            aimshootchance:Disconnect()
        end
    end
end

function AimSlashShedletsky(value)
    local aimslashsword = value
    if value then
        local shedaimbotsounds = {
            "rbxassetid://106397684977541",
            "rbxassetid://106397684977541"
        }
        aimslash = game.Players.LocalPlayer.Character.Sword.ChildAdded:Connect(function(child)
            if not aimslashsword then return end
            for _, v in ipairs(shedaimbotsounds) do
                if child.Name == v then
                    local targetkiller = game.Workspace.Players:FindFirstChild("Killers"):FindFirstChildOfClass("Model")
                    if targetkiller and targetkiller:FindFirstChild("HumanoidRootPart") then
                        if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            local distance = (targetkiller.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                            if distance <= aimDistanceSettings.SSA then
                                local number = 1
                                local smoothness = aimSmoothnessSettings.SSA
                                local duration = aimDurationSettings.SSA
                                local connection
                                connection = game:GetService("RunService").RenderStepped:Connect(function()
                                    if number <= duration then
                                        task.wait(0.01)
                                        number = number + 1
                                        local currentCF = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                                        local targetPos = targetkiller.HumanoidRootPart.Position
                                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = SmoothLookAt(currentCF, targetPos, smoothness)
                                    else
                                        connection:Disconnect()
                                    end
                                end)
                            end
                        end
                    end
                end
            end
        end)
    else
        if aimslash then
            aimslash:Disconnect()
        end
    end
end

function AimAttackGuest(value)
    local aimattackguest = value
    if value then
        aimguest = game:GetService("ReplicatedStorage").Modules.Network.RemoteEvent.OnClientEvent:Connect(function(eventName, eventArg)
            if not aimattackguest then return end
            if eventName == "UseActorAbility" and eventArg == "Punch" then
                local targetkiller = game.Workspace.Players:FindFirstChild("Killers"):FindFirstChildOfClass("Model")
                if targetkiller and targetkiller:FindFirstChild("HumanoidRootPart") then
                    if game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (targetkiller.HumanoidRootPart.Position - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                        if distance <= aimDistanceSettings.GAA then
                            local number = 1
                            local smoothness = aimSmoothnessSettings.GAA
                            local duration = aimDurationSettings.GAA
                            local connection
                            connection = game:GetService("RunService").RenderStepped:Connect(function()
                                if number <= duration then
                                    task.wait(0.01)
                                    number = number + 1
                                    local currentCF = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                                    local targetPos = targetkiller.HumanoidRootPart.Position
                                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = SmoothLookAt(currentCF, targetPos, smoothness)
                                else
                                    connection:Disconnect()
                                end
                            end)
                        end
                    end
                end
            end
        end)
    else
        if aimguest then
            aimguest:Disconnect()
        end
    end
end

SpecialAimbot:AddToggle("CSA",{
    Text = "钱斯自瞄",
    Callback = function(v)
        AimShootChance(v)
    end
})

SpecialAimbot:AddToggle("SSA",{
    Text = "谢迪自瞄",
    Callback = function(v)
        AimSlashShedletsky(v)
    end
})

SpecialAimbot:AddToggle("GAA",{
    Text = "访客自瞄",
    Callback = function(v)
        AimAttackGuest(v)
    end
})


local aimbotNoilsounds = {
    "rbxassetid://90768093259753"
}
local aimbotNoilsounds2 = {
    "rbxassetid://126318185932771"
}
local Noloop
local No2loop

-- Default settings
local aimSettings = {
    maxDistance = 50,  -- Default max aim distance
    lockTime = 3.3     -- Default lock time in seconds (330 iterations * 0.01)
}

-- 创建 Noli 自瞄组框
local g = Tabs.Aimbot:AddRightGroupbox('Noli 自瞄')

-- 向组框添加滑块
g:AddSlider('AimDistance', {
    Text = '最大自瞄距离',
    Default = aimSettings.maxDistance,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        aimSettings.maxDistance = value
    end
})

g:AddSlider('LockTime', {
    Text = '自瞄锁定时间(秒)',
    Default = aimSettings.lockTime,
    Min = 0.5,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(value)
        aimSettings.lockTime = value
    end
})

local function Noaimbot(state)
    johnaim = state
    if game:GetService("Players").LocalPlayer.Character.Name ~= "Noli" and state then
        Library:Notify("角色不对，可能出现错误", nil, 4590657391)
        return 
    end
    if state then
        Noloop = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.ChildAdded:Connect(function(child)
            if not johnaim then return end
            for _, v in pairs(aimbotNoilsounds) do
                if child.Name == v then
                   
                    local survivors = {}
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game:GetService("Players").LocalPlayer then
                            local character = player.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                table.insert(survivors, character)
                            end
                        end
                    end
    
                   
                    local nearestSurvivor = nil
                    local shortestDistance = math.huge  
                    
                    for _, survivor in pairs(survivors) do
                        local survivorHRP = survivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if playerHRP then
                            local distance = (survivorHRP.Position - playerHRP.Position).Magnitude
                            if distance < shortestDistance and distance <= aimSettings.maxDistance then
                                shortestDistance = distance
                                nearestSurvivor = survivor
                            end
                        end
                    end
                    
                  
                    if nearestSurvivor then
                        local nearestHRP = nearestSurvivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local maxIterations = math.floor(aimSettings.lockTime / 0.01)  -- Convert seconds to iterations
                        if playerHRP then
                            local direction = (nearestHRP.Position - playerHRP.Position).Unit
                            local num = 1
                           
                            while num <= maxIterations do
                                task.wait(0.01)
                                num = num + 1
                                workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, nearestHRP.Position)
                                playerHRP.CFrame = CFrame.lookAt(playerHRP.Position, Vector3.new(nearestHRP.Position.X, nearestHRP.Position.Y, nearestHRP.Position.Z))
                            end
                        end
                    end
                end
            end
        end)
    else
        if Noloop then
            Noloop:Disconnect()
            Noloop = nil
        end
    end
end

local function No2aimbot(state)
    johnaim = state
    if game:GetService("Players").LocalPlayer.Character.Name ~= "Noli" and state then
        Library:Notify("角色不对，可能出现错误", nil, 4590657391)
        return 
    end
    if state then
        No2loop = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.ChildAdded:Connect(function(child)
            if not johnaim then return end
            for _, v in pairs(aimbotNoilsounds2) do
                if child.Name == v then
                   
                    local survivors = {}
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game:GetService("Players").LocalPlayer then
                            local character = player.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                table.insert(survivors, character)
                            end
                        end
                    end
    
                   
                    local nearestSurvivor = nil
                    local shortestDistance = math.huge  
                    
                    for _, survivor in pairs(survivors) do
                        local survivorHRP = survivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        
                        if playerHRP then
                            local distance = (survivorHRP.Position - playerHRP.Position).Magnitude
                            if distance < shortestDistance and distance <= aimSettings.maxDistance then
                                shortestDistance = distance
                                nearestSurvivor = survivor
                            end
                        end
                    end
                    
                  
                    if nearestSurvivor then
                        local nearestHRP = nearestSurvivor.HumanoidRootPart
                        local playerHRP = game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local maxIterations = math.floor(aimSettings.lockTime / 0.01)  -- Convert seconds to iterations
                        if playerHRP then
                            local direction = (nearestHRP.Position - playerHRP.Position).Unit
                            local num = 1
                           
                            while num <= maxIterations do
                                task.wait(0.01)
                                num = num + 1
                                workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, nearestHRP.Position)
                                playerHRP.CFrame = CFrame.lookAt(playerHRP.Position, Vector3.new(nearestHRP.Position.X, nearestHRP.Position.Y, nearestHRP.Position.Z))
                            end
                        end
                    end
                end
            end
        end)
    else
        if No2loop then
            No2loop:Disconnect()
            No2loop = nil
        end
    end
end

-- 向组框添加开关
g:AddToggle('NoilStarBomb', {
    Text = 'Noil 星爆自瞄',
    Default = false,
    Callback = function(state)
        Noaimbot(state)
    end
})

g:AddToggle('NoilVoidRush', {
    Text = 'Noil 虚空冲刺自瞄',
    Default = false,
    Callback = function(state)
        No2aimbot(state)
    end
})



local Warning = Tabs.tzq:AddLeftGroupbox("杀手接近提醒")
-- 杀手靠近提示设置
local KillerWarningSettings = {
    Enabled = false,
    WarningDistance = 100, -- 警告距离(米)
    WarningColor = Color3.fromRGB(255, 0, 0), -- 警告颜色(红色)
    TextSize = 20, -- 文字大小
    BlinkInterval = 0.5, -- 闪烁间隔(秒)
    LastWarningTime = 0, -- 上次警告时间
    WarningCooldown = 5, -- 警告冷却时间(秒)
    WarningSoundId = "rbxassetid://6545327576", -- 警告音效ID
    SoundVolume = 0.5 -- 音效音量
}

-- 存储绘制对象
local warningLabel = Drawing.new("Text")
warningLabel.Visible = false
warningLabel.Center = true
warningLabel.Outline = true
warningLabel.Font = 2 -- 粗体字体
warningLabel.Color = KillerWarningSettings.WarningColor
warningLabel.Size = KillerWarningSettings.TextSize

-- 存储音效对象
local warningSound = Instance.new("Sound")
warningSound.SoundId = KillerWarningSettings.WarningSoundId
warningSound.Volume = KillerWarningSettings.SoundVolume
warningSound.Parent = game:GetService("SoundService")

-- 更新警告显示
local function updateKillerWarning()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return end
    
    local closestDistance = math.huge
    local closestKiller = nil
    
    -- 寻找最近的杀手
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            local distance = (character.HumanoidRootPart.Position - killer.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestKiller = killer
            end
        end
    end
    
    -- 检查距离并显示警告
    if closestKiller and closestDistance <= KillerWarningSettings.WarningDistance then
        local currentTime = tick()
        
        -- 闪烁效果
        if currentTime - KillerWarningSettings.LastWarningTime >= KillerWarningSettings.BlinkInterval then
            warningLabel.Visible = not warningLabel.Visible
            KillerWarningSettings.LastWarningTime = currentTime
        end
        
        -- 设置警告文本
        warningLabel.Text = string.format("⚠️Warning! Killer %s in %d m!", closestKiller.Name, math.floor(closestDistance))
        warningLabel.Position = Vector2.new(
            workspace.CurrentCamera.ViewportSize.X / 2,
            workspace.CurrentCamera.ViewportSize.Y * 0.2
        )
        
        -- 播放警告音效(冷却时间内只播放一次)
        if currentTime - KillerWarningSettings.LastWarningTime >= KillerWarningSettings.WarningCooldown then
            warningSound:Play()
            KillerWarningSettings.LastWarningTime = currentTime
        end
    else
        warningLabel.Visible = false
    end
end

-- 主开关
Warning:AddToggle("KillerWarningToggle", {
    Text = "开启",
    Default = false,
    Callback = function(enabled)
        KillerWarningSettings.Enabled = enabled
        if enabled then
            -- 初始化连接
            if not KillerWarningSettings.connection then
                KillerWarningSettings.connection = game:GetService("RunService").RenderStepped:Connect(updateKillerWarning)
            end
        else
            -- 关闭连接
            if KillerWarningSettings.connection then
                KillerWarningSettings.connection:Disconnect()
                KillerWarningSettings.connection = nil
            end
            warningLabel.Visible = false
            warningSound:Stop()
        end
    end
})

-- 距离设置
Warning:AddSlider("WarningDistance", {
    Text = "警告距离(米)",
    Min = 10,
    Max = 200,
    Default = 100,
    Rounding = 0,
    Callback = function(value)
        KillerWarningSettings.WarningDistance = value
    end
})

-- 文字大小设置
Warning:AddSlider("WarningTextSize", {
    Text = "文字大小",
    Min = 10,
    Max = 30,
    Default = 20,
    Rounding = 0,
    Callback = function(value)
        KillerWarningSettings.TextSize = value
        warningLabel.Size = value
    end
})

-- 闪烁速度设置
Warning:AddSlider("BlinkSpeed", {
    Text = "闪烁频率",
    Min = 0.1,
    Max = 1,
    Default = 0.5,
    Rounding = 1,
    Callback = function(value)
        KillerWarningSettings.BlinkInterval = value
    end
})

-- 警告颜色选择
Warning:AddDropdown("WarningColor", {
    Values = {"红色", "橙色", "黄色", "粉色", "紫色"},
    Default = "红色",
    Text = "文字颜色",
    Callback = function(value)
        local colorMap = {
            ["红色"] = Color3.fromRGB(255, 0, 0),
            ["橙色"] = Color3.fromRGB(255, 165, 0),
            ["黄色"] = Color3.fromRGB(255, 255, 0),
            ["粉色"] = Color3.fromRGB(255, 192, 203),
            ["紫色"] = Color3.fromRGB(128, 0, 128)
        }
        KillerWarningSettings.WarningColor = colorMap[value] or Color3.fromRGB(255, 0, 0)
        warningLabel.Color = KillerWarningSettings.WarningColor
    end
})

local Visual = Tabs.tzq:AddRightGroupbox("Noli 技能监控")

Visual:AddToggle("NoliTeleportAlert", {
    Text = "Noli 传送监视",
    Default = false,
    Callback = function(v)
        if v then
            local activeConnections = {}
            local lastNotifyTime = 0
            local COOLDOWN = 2
            local TARGET_SOUND_ID = "rbxassetid://125253972523701"

            local function safeNotify()
                local currentTime = tick()
                if currentTime - lastNotifyTime > COOLDOWN then
                    Library:Notify("warning\nNoli is transmitting")
                    lastNotifyTime = currentTime
                end
            end

            local function checkSoundPlaying(sound)
                return sound and sound.IsPlaying or false
            end

            local function monitorSound(sound)
                task.spawn(function()
                    while sound.Parent and checkSoundPlaying(sound) do
                        safeNotify()
                        task.wait(COOLDOWN)
                    end
                end)
            end

            local function setupKiller(killer)
                local humanoidRootPart = killer:WaitForChild("HumanoidRootPart", 5)
                if humanoidRootPart then
                   
                    for _, child in ipairs(humanoidRootPart:GetChildren()) do
                        if child:IsA("Sound") and child.SoundId == TARGET_SOUND_ID then
                            monitorSound(child)
                        end
                    end

                
                    local connection = humanoidRootPart.ChildAdded:Connect(function(child)
                        if child:IsA("Sound") and child.SoundId == TARGET_SOUND_ID then
                            monitorSound(child)
                        end
                    end)
                    
                    table.insert(activeConnections, connection)
                end
            end

        
            table.insert(activeConnections, workspace.Players.Killers.ChildAdded:Connect(setupKiller))

          
            for _, killer in ipairs(workspace.Players.Killers:GetChildren()) do
                task.spawn(setupKiller, killer)
            end
        else
           
            for _, conn in ipairs(activeConnections) do
                conn:Disconnect()
            end
            activeConnections = {}
        end
    end
})


Visual:AddToggle("NoliTeleportCancel", {
    Text = "Noli 传送取消监控",
    Default = false,
    Callback = function(v)
        if v then
            local activeConnections = {}
            local lastNotifyTime = 0
            local COOLDOWN = 2 
            
            local function checkSound(humanoidRootPart)
                for _, child in ipairs(humanoidRootPart:GetChildren()) do
                    if child:IsA("Sound") and child.SoundId == "rbxassetid://9125639499" and child.IsPlaying then
                        local currentTime = tick()
                        if currentTime - lastNotifyTime > COOLDOWN then
                            Library:Notify("warning\nNoli The transfer was canceled")
                            lastNotifyTime = currentTime
                        end
                        return true
                    end
                end
                return false
            end

            local function setupKiller(killer)
                local humanoidRootPart = killer:WaitForChild("HumanoidRootPart", 5)
                if humanoidRootPart then
                    local connection
                    connection = humanoidRootPart.ChildAdded:Connect(function(child)
                        if child:IsA("Sound") and child.SoundId == "rbxassetid://9125639499" then
                            task.spawn(function()
                                while child.Parent and child.IsPlaying do
                                    local currentTime = tick()
                                    if currentTime - lastNotifyTime > COOLDOWN then
                                        Library:Notify("warning\nNoli The transfer was canceled")
                                        lastNotifyTime = currentTime
                                    end
                                    task.wait(0.1)
                                end
                            end)
                        end
                    end)
                    
                    table.insert(activeConnections, connection)
                    
                    -- 初始检查
                    task.spawn(function()
                        while killer.Parent do
                            if checkSound(humanoidRootPart) then
                                task.wait(COOLDOWN)
                            else
                                task.wait(0.1)
                            end
                        end
                        connection:Disconnect()
                    end)
                end
            end

            -- 监听新杀手
            table.insert(activeConnections, workspace.Players.Killers.ChildAdded:Connect(setupKiller))
            
            -- 检查现有杀手
            for _, killer in ipairs(workspace.Players.Killers:GetChildren()) do
                task.spawn(setupKiller, killer)
            end
        else
            for _, conn in ipairs(activeConnections) do
                conn:Disconnect()
            end
            activeConnections = {}
        end
    end
})

Visual:AddToggle("NoliMotorSelect", {
    Text = "Noli 选择发电机监听",
    Default = false,
    Callback = function(v)
        local soundId = "rbxassetid://124468317999247"
        local notificationMessage = "⚠️Warning\nNoli Selecting Generator"
        local connections = {}
        local cooldown = 2 -- 通知冷却时间(秒)
        local lastNotifyTime = 0

        local function disconnectAll()
            for _, conn in pairs(connections) do
                conn:Disconnect()
            end
            connections = {}
        end

        local function safeNotify()
            local now = os.time()
            if now - lastNotifyTime >= cooldown then
                Library:Notify(notificationMessage)
                lastNotifyTime = now
            end
        end

        local function setupSoundListener(humanoidRootPart)
            local function onChildAdded(child)
                if child:IsA("Sound") and child.SoundId == soundId then
                    safeNotify()
                end
            end

            local conn = humanoidRootPart.ChildAdded:Connect(onChildAdded)
            table.insert(connections, conn)

            -- 检查已存在的音频
            for _, child in ipairs(humanoidRootPart:GetChildren()) do
                if child:IsA("Sound") and child.SoundId == soundId then
                    safeNotify()
                    break
                end
            end
        end

        local function onKillerAdded(killer)
            local humanoidRootPart = killer:FindFirstChild("HumanoidRootPart") or killer:WaitForChild("HumanoidRootPart", 3)
            if humanoidRootPart then
                setupSoundListener(humanoidRootPart)
            end
        end

        if v then
            -- 监听新杀手
            local mainConn = workspace.Players.Killers.ChildAdded:Connect(onKillerAdded)
            table.insert(connections, mainConn)

            -- 初始化现有杀手
            for _, killer in ipairs(workspace.Players.Killers:GetChildren()) do
                task.spawn(onKillerAdded, killer)
            end
        else
            disconnectAll()
        end
    end
})





Visual:AddToggle("NoliMotorSelect", {
    Text = "Noli 冲刺监控",
    Default = false,
    Callback = function(v)
        local soundId = "rbxassetid://126318185932771"
        local notificationMessage = "Noli is sprinting"
        local endNotificationMessage = "Noli冲刺结束"
        local connections = {}
        local cooldown = 2
        local lastNotifyTime = 0

        local function disconnectAll()
            for _, conn in pairs(connections) do
                conn:Disconnect()
            end
            connections = {}
        end

        local function safeNotify(message)
            local now = os.time()
            if now - lastNotifyTime >= cooldown then
                Library:Notify(message)
                lastNotifyTime = now
            end
        end

        local function setupSoundListener(humanoidRootPart)
            local function onChildAdded(child)
                if child:IsA("Sound") and child.SoundId == soundId then
                    safeNotify(notificationMessage)
                    local endedConn = child.Ended:Connect(function()
                        safeNotify(endNotificationMessage)
                        endedConn:Disconnect()
                    end)
                    table.insert(connections, endedConn)
                end
            end

            local conn = humanoidRootPart.ChildAdded:Connect(onChildAdded)
            table.insert(connections, conn)

            for _, child in ipairs(humanoidRootPart:GetChildren()) do
                if child:IsA("Sound") and child.SoundId == soundId then
                    safeNotify(notificationMessage)
                    if child.IsPlaying then
                        local endedConn = child.Ended:Connect(function()
                            safeNotify(endNotificationMessage)
                            endedConn:Disconnect()
                        end)
                        table.insert(connections, endedConn)
                    end
                    break
                end
            end
        end

        local function onKillerAdded(killer)
            local humanoidRootPart = killer:FindFirstChild("HumanoidRootPart") or killer:WaitForChild("HumanoidRootPart", 3)
            if humanoidRootPart then
                setupSoundListener(humanoidRootPart)
            end
        end

        if v then
            local mainConn = workspace.Players.Killers.ChildAdded:Connect(onKillerAdded)
            table.insert(connections, mainConn)
            for _, killer in ipairs(workspace.Players.Killers:GetChildren()) do
                task.spawn(onKillerAdded, killer)
            end
        else
            disconnectAll()
        end
    end
})




local Visual = Tabs.tzq:AddLeftGroupbox('其他功能')



Visual:AddToggle("NST",{
    Text = "子空间绊雷",
    Default = false,
    Callback = function(v)
        if v then
            NotifySubspaceTripmine = workspace.Map.Ingame.DescendantAdded:Connect(function(v)
                if v.Name == "SubspaceTripmine" then
                    Library:Notify("NOL | 警告\n检测到'子空间绊雷'生成！")
                end
            end)
        else
            NotifySubspaceTripmine:Disconnect()
        end
    end
})

Visual:AddToggle("NEK",{
    Text = "机器人生成",
    Default = false,
    Callback = function(v)
        if v then
            NotifyEntityKillers = workspace.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and v.Name == "PizzaDeliveryRig" or v.Name == "Bunny" or v.Name == "Mafiaso1" or v.Name == "Mafiaso2" or v.Name == "Mafiaso3" then
                    Library:Notify("NOL | 警告\n实体 '" .. v.Name .. "' 已生成！")
                elseif v:IsA("Model") and v.Name == "1x1x1x1Zombie" then
                    Library:Notify("NOL | 警告\n实体 '1x1x1x1 (僵尸)' 已生成！")
                end
            end)
        else
            NotifyEntityKillers:Disconnect()
        end
    end
})



local SM = Tabs.tfz:AddLeftGroupbox('显示命中框')



local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local playerName = player.Name
local hitbox = nil
local updateConnection = nil

local hitboxesFolder = Workspace:FindFirstChild("Hitboxes")
if not hitboxesFolder then
    hitboxesFolder = Instance.new("Folder")
    hitboxesFolder.Name = "Hitboxes"
    hitboxesFolder.Parent = Workspace
end

local function createHitbox()
    local part = Instance.new("Part")
    part.Name = playerName .. "_Hitbox"
    part.Size = Vector3.new(4, 7, 4)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 0.5
    part.Material = Enum.Material.ForceField
    part.Color = Color3.fromRGB(255, 255, 200)
    part.Parent = hitboxesFolder
    return part
end

local function updateHitbox()
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") and hitbox then
        local root = character.HumanoidRootPart
        local offset = root.CFrame.LookVector * 4
        hitbox.CFrame = CFrame.new(root.Position + offset, root.Position + root.CFrame.LookVector)
    end
end

SM:AddToggle("打人", {
    Text = "显示命中框",
    Default = false,
    Callback = function(state)
        if state then
       
            hitbox = createHitbox()
            updateConnection = RunService.RenderStepped:Connect(updateHitbox)
         
            player.CharacterAdded:Connect(function(char)
                task.wait(1)
                if hitbox then
                    hitbox:Destroy()
                end
                hitbox = createHitbox()
            end)
        else
            
            if updateConnection then
                updateConnection:Disconnect()
                updateConnection = nil
            end
            if hitbox then
                hitbox:Destroy()
                hitbox = nil
            end
        end
    end
})






local SM = Tabs.tfz:AddLeftGroupbox('命中框吸附')



if not _G.HitboxTracking then
    _G.HitboxTracking = {
        Connection = nil,
        Active = false,
        -- 配置参数
        Settings = {
            Strength = 1.0,      -- 吸附力度 (默认1.0)
            Distance = 12        -- 吸附距离 (默认12)
        }
    }
end


SM:AddSlider("HitboxTrackingStrength", {
    Text = "显示努力值",
    Tooltip = "Attraction intensity",
    Default = 1.0,
    Min = 0.1,      -- 最小力度
    Max = 3.0,      -- 最大力度
    Increment = 0.1, -- 增量
    Visible = true,
    Callback = function(value)
        if _G.HitboxTracking and _G.HitboxTracking.Settings then
            _G.HitboxTracking.Settings.Strength = value
        end
    end
})

SM:AddSlider("HitboxTrackingDistance", {
    Text = "显示距离",
    Tooltip = "huh",
    Default = 12,
    Min = 5,        -- 最小距离
    Max = 30,       -- 最大距离
    Increment = 1,  
    Visible = true,
    Callback = function(value)
        if _G.HitboxTracking and _G.HitboxTracking.Settings then
            _G.HitboxTracking.Settings.Distance = value
        end
    end
})

-- 主要的Toggle功能
SM:AddToggle("HitboxTrackingToggle", {
    Text = "吸附命中框",
    Tooltip = "Enable or ban",
    Default = false,
    Disabled = false,
    Visible = true,
    Risky = false,

    Callback = function(state)
        -- 关闭功能（保持不变）
        if not state then
            if _G.HitboxTracking.Connection then
                _G.HitboxTracking.Connection:Disconnect()
                _G.HitboxTracking.Connection = nil
            end
            _G.HitboxTracking.Active = false
            return
        end

        -- 确保游戏加载完成（保持不变）
        repeat task.wait() until game:IsLoaded()

        -- 初始化服务（保持不变）
        local Player = Players.LocalPlayer
        local Character = Player.Character or Player.CharacterAdded:Wait()
        local Humanoid = Character:WaitForChild("Humanoid")
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

        -- 角色变化处理（保持不变）
        Player.CharacterAdded:Connect(function(NewCharacter)
            Character = NewCharacter
            Humanoid = Character:WaitForChild("Humanoid")
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
        end)

local AttackAnimations = {
	'rbxassetid://131430497821198', --// MassInfection, 1x1x1x1
	'rbxassetid://83829782357897', --// Slash, 1x1x1x1
	'rbxassetid://126830014841198', --// Slash, Jason
	'rbxassetid://126355327951215', --// Behead, Jason
	'rbxassetid://121086746534252', --// GashingWoundStart, Jason
	'rbxassetid://105458270463374', --// Slash, JohnDoe
	'rbxassetid://127172483138092', --// CorruptEnergy, JohnDoe
	'rbxassetid://18885919947', --// CorruptNature, c00lkidd
	'rbxassetid://18885909645', --// Attack, c00lkidd
	'rbxassetid://87259391926321', --// ParryPunch, Guest1337
	'rbxassetid://106014898528300', --// Charge, Guest1337
	'rbxassetid://87259391926321', --// Punch, Guest1337
	'rbxassetid://86545133269813', --// Stab, TwoTime
	'rbxassetid://89448354637442', --// LungeStart, TwoTime
	'rbxassetid://90499469533503', --// GunFire, Chance
	'rbxassetid://116618003477002', --// Slash, Shedletsky
	'rbxassetid://106086955212611', --// Stab, TwoTime, Skin: PhilosopherTwotime
	'rbxassetid://107640065977686', --// LungeStart, TwoTime, Skin: PhilosopherTwotime
	'rbxassetid://77124578197357', --// GunFire, Chance, Skin: OutlawChance
	'rbxassetid://101771617803133', --// GunFire, Chance, Skin: #CassidyChance
	'rbxassetid://134958187822107', --// GunFire, Chance, Skin: RetroChance
	'rbxassetid://111313169447787', --// GunFire, Chance, Skin: MLGChance
	'rbxassetid://71685573690338', --// GunFire, Chance, Skin: Milestone100Chance
	'rbxassetid://71685573690338', --// GunFire, Chance, Skin: Milestone75Chance
	'rbxassetid://129843313690921', --// ParryPunch, Guest1337, Skin: #NerfedDemomanGuest
	'rbxassetid://97623143664485', --// Charge, Guest1337, Skin: #NerfedDemomanGuest
	'rbxassetid://129843313690921', --// Punch, Guest1337, Skin: #NerfedDemomanGuest
	'rbxassetid://136007065400978', --// ParryPunch, Guest1337, Skin: LittleBrotherGuest
	'rbxassetid://136007065400978', --// Punch, Guest1337, Skin: LittleBrotherGuest
	'rbxassetid://86096387000557', --// ParryPunch, Guest1337, Skin: Milestone100Guest
	'rbxassetid://86096387000557', --// ParryPunch, Guest1337, Skin: Milestone75Guest
	'rbxassetid://108807732150251', --// ParryPunch, Guest1337, Skin: GreenbeltGuest
	'rbxassetid://138040001965654', --// Punch, Guest1337, Skin: GreenbeltGuest
	'rbxassetid://73502073176819', --// Charge, Guest1337, Skin: GreenbeltGuest
	'rbxassetid://129843313690921', --// ParryPunch, Guest1337, Skin: #DemomanGuest
	'rbxassetid://97623143664485', --// Charge, Guest1337, Skin: #DemomanGuest
	'rbxassetid://129843313690921', --// Punch, Guest1337, Skin: #DemomanGuest
	'rbxassetid://97623143664485', --// Charge, Guest1337, Skin: GunnerGuest
	'rbxassetid://97623143664485', --// Charge, Guest1337, Skin: BobbyGuest
	'rbxassetid://97623143664485', --// Charge, Guest1337, Skin: !JuggernautGuest
	'rbxassetid://86709774283672', --// ParryPunch, Guest1337, Skin: SorcererGuest
	'rbxassetid://106014898528300', --// Charge, Guest1337, Skin: SorcererGuest
	'rbxassetid://87259391926321', --// Punch, Guest1337, Skin: SorcererGuest
	'rbxassetid://140703210927645', --// ParryPunch, Guest1337, Skin: DragonGuest
	'rbxassetid://96173857867228', --// Charge, Guest1337, Skin: AllyGuest
	'rbxassetid://121255898612475', --// Slash, Shedletsky, Skin: RetroShedletsky
	'rbxassetid://98031287364865', --// Slash, Shedletsky, Skin: BrightEyesShedletsky
	'rbxassetid://119462383658044', --// Slash, Shedletsky, Skin: NessShedletsky
	'rbxassetid://77448521277146', --// Slash, Shedletsky, Skin: Milestone100Shedletsky
	'rbxassetid://77448521277146', --// Slash, Shedletsky, Skin: Milestone75Shedletsky
	'rbxassetid://103741352379819', --// Slash, Shedletsky, Skin: #RolandShedletsky
	'rbxassetid://119462383658044', --// Slash, Shedletsky, Skin: HeartbrokenShedletsky
	'rbxassetid://131696603025265', --// Slash, Shedletsky, Skin: JamesSunderlandShedletsky
	'rbxassetid://122503338277352', --// Slash, Shedletsky, Skin: SkiesShedletsky
	'rbxassetid://97648548303678', --// Slash, Shedlet很长... (保持您原有的长动画ID列表不变)
};

        local RNG = Random.new()

        -- 清除旧连接（保持不变）
        if _G.HitboxTracking.Connection then
            _G.HitboxTracking.Connection:Disconnect()
        end

        -- 标记为活动状态（保持不变）
        _G.HitboxTracking.Active = true

        -- 创建新连接（改进部分开始）
        _G.HitboxTracking.Connection = RunService.Heartbeat:Connect(function()
            -- 双重活动检查（保持不变）
            if not _G.HitboxTracking.Active then return end
            if not HumanoidRootPart or not HumanoidRootPart:IsDescendantOf(workspace) then return end

            -- 攻击动画检测（保持不变）
            local isAttacking = false
            for _, track in pairs(Humanoid:GetPlayingAnimationTracks()) do
                if track.Animation and table.find(AttackAnimations, track.Animation.AnimationId) then
                    if (track.TimePosition / track.Length) < 0.75 then
                        isAttacking = true
                        break
                    end
                end
            end

            if not isAttacking then return end

            -- 改进的目标查找和预测系统
            local target, nearestDist = nil, _G.HitboxTracking.Settings.Distance  -- 使用配置的距离
            local myPos = HumanoidRootPart.Position
            local ping = Player:GetNetworkPing()
            
            -- 精确的目标筛选函数
            local function findTargets(targets)
                for _, entity in pairs(targets) do
                    if entity == Character or not entity:FindFirstChild("HumanoidRootPart") then
                        continue
                    end

                    local targetRoot = entity.HumanoidRootPart
                    local targetVel = targetRoot.Velocity
                    local targetPos = targetRoot.Position
                    
                    -- 预测目标位置（考虑ping和速度）
                    local predictedPos = targetPos + (targetVel * (ping * 1.5))
                    
                    -- 计算精确距离（考虑目标体积）
                    local distance = (predictedPos - myPos).Magnitude
                    local targetSize = targetRoot.Size.Magnitude / 2
                    
                    -- 调整有效命中距离
                    if distance < (nearestDist + targetSize) then
                        nearestDist = distance
                        target = {
                            entity = entity,
                            position = predictedPos,
                            velocity = targetVel
                        }
                    end
                end
            end

            -- 检查玩家（保持不变）
            if workspace:FindFirstChild("Players") then
                findTargets(workspace.Players:GetDescendants())
            end
            
            -- 检查NPC（保持不变）
            local npcsFolder = workspace.Map:FindFirstChild("NPCs", true)
            if npcsFolder then
                findTargets(npcsFolder:GetChildren())
            end

            if not target then return end

            -- 高级运动补偿计算
            local randomOffset = Vector3.new(
                RNG:NextNumber(-0.8, 0.8),  -- 减少随机偏移量以提高精度
                RNG:NextNumber(-0.3, 0.3),
                RNG:NextNumber(-0.8, 0.8)
            )
            
            -- 计算精确的所需速度（使用配置的力度）
            local strengthMultiplier = _G.HitboxTracking.Settings.Strength
            local requiredVelocity = (target.position + randomOffset - myPos) / (ping * 1.8)
            
            -- 添加目标速度补偿
            requiredVelocity = requiredVelocity + (target.velocity * 0.6)
            
            -- 应用力度乘数
            requiredVelocity = requiredVelocity * strengthMultiplier

            -- 应用移动（保持不变）
            local originalVelocity = HumanoidRootPart.Velocity
            HumanoidRootPart.Velocity = requiredVelocity
            task.wait()
            HumanoidRootPart.Velocity = originalVelocity
        end)
    end
})







local SM = Tabs.tfz:AddRightGroupbox('命中框追踪')

local HitboxTrackingEnabled = false
local HeartbeatConnection = nil
local TrackingMode = "vision"
local TargetLine = nil
local MaxDistance = 12
local TrackingCircle = nil
local ShowRangeCircle = false
local RangePart = nil

local players = game:GetService("Players")
local run_service = game:GetService("RunService")
local local_player = players.LocalPlayer
local camera = workspace.CurrentCamera

SM:AddDropdown("TrackingModeDropdown", {
    Values = {"vision", "recent"},
    Default = 1,
    Multi = false,
    Text = "追踪模式",
    Callback = function(value)
        TrackingMode = value
        if TrackingCircle then
            TrackingCircle.Visible = (value == "vision")
        end
    end
})

SM:AddSlider("DistanceSlider", {
    Text = "距离",
    Default = 12,
    Min = 1,
    Max = 150,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        MaxDistance = value
    end
})

SM:AddSlider("CircleSizeSlider", {
    Text = "Fov",
    Default = 100,
    Min = 0,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        if TrackingCircle then
            TrackingCircle.Radius = value
        end
    end
})


SM:AddToggle("HitboxTrackingToggle", {
    Text = "命中框追踪",
    Default = false,
    Callback = function(state)
        HitboxTrackingEnabled = state
        
        if HeartbeatConnection then
            HeartbeatConnection:Disconnect()
            HeartbeatConnection = nil
        end
        
        if TargetLine then
            TargetLine:Remove()
            TargetLine = nil
        end
        
        if TrackingCircle then
            TrackingCircle:Remove()
            TrackingCircle = nil
        end
        
        if not state then return end
        
        TargetLine = Drawing.new("Line")
        TargetLine.Visible = false
        TargetLine.Thickness = 1
        TargetLine.Transparency = 1
        
        TrackingCircle = Drawing.new("Circle")
        TrackingCircle.Visible = (TrackingMode == "vision")
        TrackingCircle.Thickness = 2
        TrackingCircle.Filled = false
        TrackingCircle.Color = Color3.fromRGB(255, 0, 0)
        TrackingCircle.Radius = 100
        TrackingCircle.Position = camera.ViewportSize / 2
        
        if ShowRangeCircle and not RangePart then
            RangePart = Instance.new("Part", workspace)
            RangePart.Material = Enum.Material.ForceField
            RangePart.Anchored = true
            RangePart.CanCollide = false
            RangePart.CastShadow = false
            RangePart.Shape = Enum.PartType.Ball
            RangePart.Color = Color3.fromRGB(132, 0, 255)
            RangePart.Transparency = 0.5
            showRange(true)
        end
        
        repeat task.wait() until game:IsLoaded();

        local Player = game:GetService("Players").LocalPlayer;
        local PlayerGui = Player:WaitForChild("PlayerGui");
        local Character = Player.Character or Player.CharacterAdded:Wait();
        local Humanoid = Character:WaitForChild("Humanoid");
        local Animator = Humanoid:WaitForChild("Animator");
        local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart");

        Player.CharacterAdded:Connect(function(NewCharacter)
            Character = NewCharacter;
            Humanoid = Character:WaitForChild("Humanoid");
            Animator = Humanoid:WaitForChild("Animator");
            HumanoidRootPart = Character:WaitForChild("HumanoidRootPart");
        end);

        local AttackAnimations = {
	'rbxassetid://131430497821198',
	'rbxassetid://83829782357897',
	'rbxassetid://126830014841198',
	'rbxassetid://126355327951215',
	'rbxassetid://121086746534252',
	'rbxassetid://105458270463374',
	'rbxassetid://127172483138092',
	'rbxassetid://18885919947',
	'rbxassetid://18885909645',
	'rbxassetid://87259391926321',
	'rbxassetid://106014898528300',
	'rbxassetid://87259391926321',
	'rbxassetid://86545133269813',
	'rbxassetid://89448354637442',
	'rbxassetid://90499469533503',
	'rbxassetid://116618003477002',
	'rbxassetid://106086955212611',
	'rbxassetid://107640065977686',
	'rbxassetid://77124578197357',
	'rbxassetid://101771617803133',
	'rbxassetid://134958187822107',
	'rbxassetid://111313169447787',
	'rbxassetid://71685573690338',
	'rbxassetid://71685573690338',
	'rbxassetid://129843313690921',
	'rbxassetid://97623143664485',
	'rbxassetid://129843313690921',
	'rbxassetid://136007065400978',
	'rbxassetid://136007065400978',
	'rbxassetid://86096387000557',
	'rbxassetid://86096387000557',
	'rbxassetid://108807732150251',
	'rbxassetid://138040001965654',
	'rbxassetid://73502073176819',
	'rbxassetid://129843313690921',
	'rbxassetid://97623143664485',
	'rbxassetid://129843313690921',
	'rbxassetid://97623143664485',
	'rbxassetid://97623143664485',
	'rbxassetid://97623143664485',
	'rbxassetid://86709774283672',
	'rbxassetid://106014898528300',
	'rbxassetid://87259391926321',
	'rbxassetid://140703210927645',
	'rbxassetid://96173857867228',
	'rbxassetid://121255898612475',
	'rbxassetid://98031287364865',
	'rbxassetid://119462383658044',
	'rbxassetid://77448521277146',
	'rbxassetid://77448521277146',
	'rbxassetid://103741352379819',
	'rbxassetid://119462383658044',
	'rbxassetid://131696603025265',
	'rbxassetid://122503338277352',
	'rbxassetid://97648548303678',
	'rbxassetid://94162446513587',
	'rbxassetid://84426150435898',
	'rbxassetid://93069721274110',
	'rbxassetid://114620047310688',
	'rbxassetid://97433060861952',
	'rbxassetid://82183356141401',
	'rbxassetid://100592913030351',
	'rbxassetid://121293883585738',
	'rbxassetid://100592913030351',
	'rbxassetid://121293883585738',
	'rbxassetid://100592913030351',
	'rbxassetid://121293883585738',
	'rbxassetid://70447634862911',
	'rbxassetid://92173139187970',
	'rbxassetid://106847695270773',
	'rbxassetid://125403313786645',
	'rbxassetid://81639435858902',
	'rbxassetid://137314737492715',
	'rbxassetid://120112897026015',
	'rbxassetid://82113744478546',
	'rbxassetid://118298475669935',
	'rbxassetid://82113744478546',
	'rbxassetid://118298475669935',
	'rbxassetid://126681776859538',
	'rbxassetid://129976080405072',
	'rbxassetid://109667959938617',
	'rbxassetid://74707328554358',
	'rbxassetid://133336594357903',
	'rbxassetid://86204001129974',
	'rbxassetid://82113744478546',
	'rbxassetid://118298475669935',
	'rbxassetid://124243639579224',
	'rbxassetid://70371667919898',
	'rbxassetid://131543461321709',
	'rbxassetid://136323728355613',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://109230267448394',
    'rbxassetid://104744456957363',
    'rbxassetid://106538427162796',
    'rbxassetid://117451341682452',
    'rbxassetid://122580527125278',
    'rbxassetid://125504560920616',
    'rbxassetid://126896426760253',
    'rbxassetid://128923537868786',
    'rbxassetid://129491851057694',
    'rbxassetid://134053005930385',
    'rbxassetid://135884061951801',
    'rbxassetid://139321362207112',
    'rbxassetid://139835501033932',
    'rbxassetid://140042539182927',
    'rbxassetid://140061272138793'
};

        local RNG = Random.new();
        HeartbeatConnection = game:GetService('RunService').Heartbeat:Connect(function()
            if not HitboxTrackingEnabled or not HumanoidRootPart then
                TargetLine.Visible = false
                return;
            end

            local Playing = false;
            for _,v in Humanoid:GetPlayingAnimationTracks() do
                if table.find(AttackAnimations, v.Animation.AnimationId) and (v.TimePosition / v.Length < 0.75) then
                    Playing = true;
                end
            end

            if not Playing then
                TargetLine.Visible = false
                return;
            end

            local Target;
            local NearestDist = MaxDistance;
            local centerPos = camera.ViewportSize / 2

            local function loop(t)
                for _,v in t do
                    if v == Character or not v:FindFirstChild("HumanoidRootPart") then
                        continue;
                    end

                    local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude;
                    
                    if TrackingMode == "vision" then
                        local screenPos, onScreen = camera:WorldToViewportPoint(v.HumanoidRootPart.Position)
                        if onScreen and Dist < NearestDist then
                            local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - centerPos).Magnitude
                            if screenDist <= TrackingCircle.Radius then
                                NearestDist = Dist
                                Target = v
                            end
                        end
                    else
                        if Dist < NearestDist then
                            NearestDist = Dist;
                            Target = v;
                        end
                    end
                end
            end

            loop(workspace.Players:GetDescendants());
            loop(workspace.Map:FindFirstChild("NPCs", true):GetChildren());

            if not Target then
                TargetLine.Visible = false
                return;
            end

            local screenPos, onScreen = camera:WorldToViewportPoint(Target.HumanoidRootPart.Position)
            if onScreen then
                TargetLine.From = centerPos
                TargetLine.To = Vector2.new(screenPos.X, screenPos.Y)
                TargetLine.Visible = true
                
                if Target:FindFirstChild("IsKiller") and Target.IsKiller.Value then
                    TargetLine.Color = Color3.fromRGB(255, 0, 0)
                elseif Target:IsA("Model") and Target:FindFirstChild("Humanoid") then
                    TargetLine.Color = Color3.fromRGB(0, 255, 255)
                else
                    TargetLine.Color = Color3.fromRGB(255, 255, 255)
                end
            else
                TargetLine.Visible = false
            end

            if ShowRangeCircle and RangePart and HumanoidRootPart then
                RangePart.CFrame = HumanoidRootPart.CFrame
                RangePart.Size = Vector3.new(MaxDistance * 2, MaxDistance * 2, MaxDistance * 2)
            end

            local OldVelocity = HumanoidRootPart.Velocity;
            local NeededVelocity =
            (Target.HumanoidRootPart.Position + vector.create(
                RNG:NextNumber(-1.5, 1.5),
                0,
                RNG:NextNumber(-1.5, 1.5)
            ) + (Target.HumanoidRootPart.Velocity * (Player:GetNetworkPing() * 1.25))
                - HumanoidRootPart.Position
            ) / (Player:GetNetworkPing() * 2);

            HumanoidRootPart.Velocity = NeededVelocity;
            game:GetService('RunService').RenderStepped:Wait();
            HumanoidRootPart.Velocity = OldVelocity;
        end);
    end,
})

local ZZ = Tabs.ani:AddLeftGroupbox('Noli 反制')

local noliDeleterActive = false
local deletionConnection = nil
local allowedNoli = nil
local isVoidRushCrashed = false
local characterCheckLoop = nil
local voidRushOverrideActive = false
local voidRushState = {}
local RunService = game:GetService("RunService")

local function deleteNewNoli()
    local killersFolder = workspace:WaitForChild("Players")
    local killers = killersFolder:WaitForChild("Killers")
    
    allowedNoli = killers:FindFirstChild("Noli")
    if not allowedNoli then
        return
    end
    
    if deletionConnection then
        deletionConnection:Disconnect()
        deletionConnection = nil
    end
    
    deletionConnection = RunService.Heartbeat:Connect(function()
        allowedNoli = killers:FindFirstChild("Noli")
        
        if not allowedNoli then
            if deletionConnection then
                deletionConnection:Disconnect()
                deletionConnection = nil
            end
            return
        end
        
        for _, child in killers:GetChildren() do
            if child.Name == "Noli" and child ~= allowedNoli then
                child:Destroy()
            end
        end
    end)
end

ZZ:AddToggle("NoliDeleter", {
    Text = "反制Noli",
    Default = false,
    Callback = function(enabled)
        noliDeleterActive = enabled
        
        if enabled then
            if deletionConnection then
                deletionConnection:Disconnect()
                deletionConnection = nil
            end
            
            local success, err = pcall(function()
                deleteNewNoli()
            end)
            
            if not success then
                noliDeleterActive = false
            end
        else
            if deletionConnection then
                deletionConnection:Disconnect()
                deletionConnection = nil
            end
            allowedNoli = nil
        end
    end
})

local killersFolder = workspace:WaitForChild("Players")
local killers = killersFolder:WaitForChild("Killers")

killers.ChildAdded:Connect(function(child)
    if noliDeleterActive and child.Name == "Noli" and not deletionConnection then
        task.wait(0.5)
        if noliDeleterActive and not deletionConnection then
            deleteNewNoli()
        end
    end
end)

local player = game:GetService("Players").LocalPlayer

local function manageVoidRushState(character)
    while isVoidRushCrashed and character and character.Parent do
        character:SetAttribute("VoidRushState", "Crashed")
        task.wait(0.5)
    end
end

ZZ:AddToggle("無視障礙[Noli]", {
    Text = "无视障碍Noli[Ignore obstacles]",
    Default = false,
    Callback = function(enabled)
        isVoidRushCrashed = enabled
        local character = player.Character
        
        if characterCheckLoop then
            task.cancel(characterCheckLoop)
            characterCheckLoop = nil
        end
        
        if enabled then
            if character then
                characterCheckLoop = task.spawn(function()
                    manageVoidRushState(character)
                end)
            end
        else
            if character then
                character:SetAttribute("VoidRushState", nil)
            end
        end
    end
})

player.CharacterAdded:Connect(function(newCharacter)
    if isVoidRushCrashed then
        if characterCheckLoop then
            task.cancel(characterCheckLoop)
        end
        characterCheckLoop = task.spawn(function()
            manageVoidRushState(newCharacter)
        end)
    end
end)

ZZ:AddToggle("VoidRushOverride", {
    Text = "Noli 虚空冲刺[锁定视角]",
    Default = false,
    Callback = function(enabled)
        voidRushOverrideActive = enabled
        
        if voidRushState.monitorTask then
            task.cancel(voidRushState.monitorTask)
            voidRushState.monitorTask = nil
        end
        
        if voidRushState.overrideConnection then
            voidRushState.overrideConnection:Disconnect()
            voidRushState.overrideConnection = nil
        end
        
        if voidRushState.characterAddedConnection then
            voidRushState.characterAddedConnection:Disconnect()
            voidRushState.characterAddedConnection = nil
        end
        
        if enabled then
            local LocalPlayer = game:GetService("Players").LocalPlayer
            local ORIGINAL_DASH_SPEED = 60
            local DEFAULT_WALK_SPEED = 16
            
            local function setupCharacter()
                if LocalPlayer.Character then
                    local Character = LocalPlayer.Character
                    local Humanoid = Character:FindFirstChildOfClass("Humanoid")
                    local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
                    
                    if Humanoid then
                        Humanoid.WalkSpeed = DEFAULT_WALK_SPEED
                        Humanoid.AutoRotate = true
                    end
                    
                    return Character, Humanoid, HumanoidRootPart
                end
                return nil, nil, nil
            end
            
            local function startOverride(Humanoid, HumanoidRootPart)
                if voidRushState.overrideConnection then return end
                
                voidRushState.overrideConnection = RunService.RenderStepped:Connect(function()
                    if not Humanoid or not HumanoidRootPart or not voidRushOverrideActive then
                        return
                    end
                    
                    Humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
                    Humanoid.AutoRotate = false
                    
                    local direction = HumanoidRootPart.CFrame.LookVector
                    local horizontalDirection = Vector3.new(direction.X, 0, direction.Z).Unit
                    Humanoid:Move(horizontalDirection)
                end)
            end
            
            local function stopOverride()
                if voidRushState.overrideConnection then
                    voidRushState.overrideConnection:Disconnect()
                    voidRushState.overrideConnection = nil
                end
                
                local Character, Humanoid = setupCharacter()
                if Humanoid then
                    Humanoid.WalkSpeed = DEFAULT_WALK_SPEED
                    Humanoid.AutoRotate = true
                    Humanoid:Move(Vector3.new(0, 0, 0))
                end
            end
            
            local function monitorVoidRush()
                while voidRushOverrideActive do
                    local Character, Humanoid, HumanoidRootPart = setupCharacter()
                    
                    if Character and Humanoid and HumanoidRootPart then
                        local voidRushStateAttr = Character:GetAttribute("VoidRushState")
                        if voidRushStateAttr == "Dashing" then
                            startOverride(Humanoid, HumanoidRootPart)
                        else
                            stopOverride()
                        end
                    end
                    
                    task.wait()
                end
                stopOverride()
            end
            
            voidRushState.monitorTask = task.spawn(monitorVoidRush)
            
            voidRushState.characterAddedConnection = LocalPlayer.CharacterAdded:Connect(function(newChar)
                if voidRushOverrideActive then
                    local Humanoid = newChar:WaitForChildOfClass("Humanoid")
                    local HumanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
                    Humanoid.WalkSpeed = DEFAULT_WALK_SPEED
                    Humanoid.AutoRotate = true
                end
            end)
        end
    end
})

local ZZ = Tabs.ani:AddRightGroupbox('1x4 反制')
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

local AutoPopup = {
    Enabled = false,
    Task = nil,
    Connections = {},
    Interval = 0.5
}

local function deletePopups()
    if not LocalPlayer or not LocalPlayer:FindFirstChild("PlayerGui") then
        return false
    end
    
    local tempUI = LocalPlayer.PlayerGui:FindFirstChild("TemporaryUI")
    if not tempUI then
        return false
    end
    
    local deleted = false
    for _, popup in ipairs(tempUI:GetChildren()) do
        if popup.Name == "1x1x1x1Popup" then
            popup:Destroy()
            deleted = true
        end
    end
    return deleted
end

local function triggerEntangled()
    local args = {
        [1] = "Entangled",
        [2] = {}
    }
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent"):FireServer(unpack(args))
    end)
end

local function setupPopupListener()
    if not LocalPlayer or not LocalPlayer:FindFirstChild("PlayerGui") then return end
    
    local tempUI = LocalPlayer.PlayerGui:FindFirstChild("TemporaryUI")
    if not tempUI then
        tempUI = Instance.new("Folder")
        tempUI.Name = "TemporaryUI"
        tempUI.Parent = LocalPlayer.PlayerGui
    end
    
    if AutoPopup.Connections.ChildAdded then
        AutoPopup.Connections.ChildAdded:Disconnect()
    end
    
    AutoPopup.Connections.ChildAdded = tempUI.ChildAdded:Connect(function(child)
        if AutoPopup.Enabled and child.Name == "1x1x1x1Popup" then
            task.defer(function()
                child:Destroy()
                triggerEntangled()
            end)
        end
    end)
end

local function runMainTask()
    while AutoPopup.Enabled do
        deletePopups()
        task.wait(AutoPopup.Interval)
    end
end

local function startAutoPopup()
    if AutoPopup.Enabled then return end
    
    AutoPopup.Enabled = true
    setupPopupListener()
    
    if AutoPopup.Task then
        task.cancel(AutoPopup.Task)
    end
    AutoPopup.Task = task.spawn(runMainTask)
end

local function stopAutoPopup()
    if not AutoPopup.Enabled then return end
    
    AutoPopup.Enabled = false
    
    if AutoPopup.Task then
        task.cancel(AutoPopup.Task)
        AutoPopup.Task = nil
    end
    
    for _, connection in pairs(AutoPopup.Connections) do
        connection:Disconnect()
    end
    AutoPopup.Connections = {}
end

ZZ:AddSlider('AutoPopupInterval', {
    Text = '反制间隔(秒)',
    Default = 0.5,
    Min = 0.5,
    Max = 2,
    Rounding = 0,
    Tooltip = '(1-5s)',
    Callback = function(value)
        AutoPopup.Interval = value
    end
})

ZZ:AddToggle('AutoPopupToggle', {
    Text = '反制弹窗提示',
    Default = false,
    Tooltip = 'Anti',
    Callback = function(state)
        if state then
            startAutoPopup()
        else
            stopAutoPopup()
        end
    end
})

if LocalPlayer then
    LocalPlayer:GetPropertyChangedSignal("Parent"):Connect(function()
        if not LocalPlayer.Parent then
            stopAutoPopup()
        end
    end)
end


ZZ:AddToggle("RemoveUnstableEye", {
    Text = "反制不稳定之眼[无法移动]", 
    Default = false,
    Callback = function(v)
        if not _G.UnstableEyeCleanup then _G.UnstableEyeCleanup = {} end
        local connections = _G.UnstableEyeCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.UnstableEyeCleanup = {}

        if not v then return end

        local function CleanUnstableEyeEffects()
            local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
            if not killersFolder then return end
            
            for _, killer in ipairs(killersFolder:GetDescendants()) do
                if killer.Name == "UnstableEye" then
                    killer:Destroy()
                end
            end
        end

        task.spawn(CleanUnstableEyeEffects)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            CleanUnstableEyeEffects()
        end)

        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        if killersFolder then
            connections.descendantAdded = killersFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "UnstableEye" then
                    descendant:Destroy()
                end
            end)
        end
    end
})

ZZ:AddToggle("RemoveBlindness", {
    Text = "反制致盲", 
    Default = false,
    Callback = function(v)
        if not _G.BlindnessCleanup then _G.BlindnessCleanup = {} end
        local connections = _G.BlindnessCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.BlindnessCleanup = {}

        if not v then return end

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local modulesFolder = ReplicatedStorage:FindFirstChild("Modules")
        local statusEffects = modulesFolder and modulesFolder:FindFirstChild("StatusEffects")
        
        if not statusEffects then
            warn("未找到 ReplicatedStorage.Modules.StatusEffects 路径")
            return
        end
        
        local function RemoveBlindness()
            local blindness = statusEffects:FindFirstChild("Blindness")
            if blindness then
                blindness:Destroy()
            end
        end

        task.spawn(RemoveBlindness)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            RemoveBlindness()
        end)

        connections.descendantAdded = statusEffects.DescendantAdded:Connect(function(descendant)
            if descendant.Name == "Blindness" then
                task.wait(0.1)
                descendant:Destroy()
            end
        end)
    end
})

local ZZ = Tabs.ani:AddRightGroupbox('Sedletsk 反制')

ZZ:AddToggle("RemoveStunningKiller", {
    Text = "反制斩击减速", 
    Default = false,
    Callback = function(v)
        if not _G.StunningKillerCleanup then _G.StunningKillerCleanup = {} end
        local connections = _G.StunningKillerCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.StunningKillerCleanup = {}

        if not v then return end

        local function CleanStunningKillers()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            local survivorList = survivorsFolder:GetChildren()
            for i = 1, #survivorList, 5 do
                task.spawn(function()
                    for j = i, math.min(i + 4, #survivorList) do
                        local survivor = survivorList[j]
                        local stunningKiller = survivor:FindFirstChild("StunningKiller")
                        if stunningKiller then
                            stunningKiller:Destroy()
                        end
                    end
                end)
            end
        end

        task.spawn(CleanStunningKillers)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(2)
            CleanStunningKillers()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "StunningKiller" then
                    descendant:Destroy()
                end
            end)
        end
    end
})

local ZZ2 = Tabs.ani:AddRightGroupbox('NOOB 反制')

ZZ2:AddToggle("RemoveSlateskin", {
    Text = "反制缓慢石", 
    Default = false,
    Callback = function(v)
        if not _G.SlateskinCleanup then _G.SlateskinCleanup = {} end
        local connections = _G.SlateskinCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.SlateskinCleanup = {}

        if not v then return end

        local function CleanSlateskins()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            local survivorList = survivorsFolder:GetChildren()
            for i = 1, #survivorList, 5 do
                task.spawn(function()
                    for j = i, math.min(i + 4, #survivorList) do
                        local survivor = survivorList[j]
                        local slateskin = survivor:FindFirstChild("SlateskinStatus")
                        if slateskin then
                            slateskin:Destroy()
                        end
                    end
                end)
            end
        end

        task.spawn(CleanSlateskins)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(2)
            CleanSlateskins()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "SlateskinStatus" then
                    descendant:Destroy()
                end
            end)
        end
    end
})




local Disabled = Tabs.ani:AddLeftGroupbox('Guest 1337 反制')

Disabled:AddToggle("RemoveSlowed", {
    Text = "反制减速", 
    Default = false,
    Callback = function(v)
        if not _G.SlowedCleanup then _G.SlowedCleanup = {} end
        local connections = _G.SlowedCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.SlowedCleanup = {}

        if not v then return end

        local function CleanSlowedStatuses()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            for _, survivor in ipairs(survivorsFolder:GetDescendants()) do
                if survivor.Name == "SlowedStatus" then
                    survivor:Destroy()
                end
            end
        end

        task.spawn(CleanSlowedStatuses)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            CleanSlowedStatuses()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "SlowedStatus" then
                    descendant:Destroy()
                end
            end)
        end
    end
})

Disabled:AddToggle("RemoveBlockingSlow", {
    Text = "反制格挡减速", 
    Default = false,
    Callback = function(v)
        if not _G.BlockingCleanup then _G.BlockingCleanup = {} end
        local connections = _G.BlockingCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.BlockingCleanup = {}

        if not v then return end

        local function CleanStatuses()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            for _, survivor in ipairs(survivorsFolder:GetDescendants()) do
                if survivor.Name == "ResistanceStatus" or survivor.Name == "GuestBlocking" then
                    survivor:Destroy()
                end
            end
        end

        task.spawn(CleanStatuses)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            CleanStatuses()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "ResistanceStatus" or descendant.Name == "GuestBlocking" then
                    descendant:Destroy()
                end
            end)
        end
    end
})

Disabled:AddToggle("RemovePunchSlow", {
    Text = "反制拳击减速", 
    Default = false,
    Callback = function(v)
        if not _G.PunchCleanup then _G.PunchCleanup = {} end
        local connections = _G.PunchCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.PunchCleanup = {}

        if not v then return end

        local function CleanStatuses()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            for _, survivor in ipairs(survivorsFolder:GetDescendants()) do
                if survivor.Name == "ResistanceStatus" or survivor.Name == "PunchAbility" then
                    survivor:Destroy()
                end
            end
        end

        task.spawn(CleanStatuses)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            CleanStatuses()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "ResistanceStatus" or descendant.Name == "PunchAbility" then
                    descendant:Destroy()
                end
            end)
        end
    end
})

Disabled:AddToggle("RemoveChargeEnded", {
    Text = "反制反向冲刺", 
    Default = false,
    Callback = function(v)
        if not _G.ChargeEndedCleanup then _G.ChargeEndedCleanup = {} end
        local connections = _G.ChargeEndedCleanup

        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" then
                conn:Disconnect()
            end
        end
        _G.ChargeEndedCleanup = {}

        if not v then return end

        local function CleanChargeEndedEffects()
            local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
            if not survivorsFolder then return end
            
            for _, survivor in ipairs(survivorsFolder:GetDescendants()) do
                if survivor.Name == "GuestChargeEnded" then
                    survivor:Destroy()
                end
            end
        end

        task.spawn(CleanChargeEndedEffects)

        connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(1.5)
            CleanChargeEndedEffects()
        end)

        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if survivorsFolder then
            connections.descendantAdded = survivorsFolder.DescendantAdded:Connect(function(descendant)
                if descendant.Name == "GuestChargeEnded" then
                    descendant:Destroy()
                end
            end)
        end
    end
})










local PZ = Tabs.lol:AddLeftGroupbox("自动吃披萨")

local pizzaConnection = nil
local pizzaTPConnection = nil
local pizzaAttractionActive = false
local pizzaCache = {}
local pizzaEffects = {}

local function createPizzaEffect(pizza, effectName)
    if not pizza:FindFirstChild(effectName) then
        local effect = Instance.new("ParticleEmitter")
        effect.Name = effectName
        effect.Texture = "rbxassetid://242487987"
        effect.LightEmission = 0.8
        effect.Size = NumberSequence.new(0.5)
        if effectName == "TeleportEffect" then
            effect.Lifetime = NumberRange.new(0.5)
        end
        effect.Parent = pizza
        pizzaEffects[pizza] = effect
        return effect
    end
    return pizzaEffects[pizza]
end

local function cleanUpEffects()
    for pizza, effect in pairs(pizzaEffects) do
        if not pizza or not pizza.Parent then
            effect:Destroy()
            pizzaEffects[pizza] = nil
        end
    end
end

local function findClosestPizza(rootPart)
    local pizzaFolder = workspace:FindFirstChild("Pizzas") or workspace.Map
    if not pizzaFolder then return nil end
    
    local closestPizza, closestDistance = nil, math.huge
    for _, pizza in ipairs(pizzaFolder:GetDescendants()) do
        if pizza:IsA("BasePart") and pizza.Name == "Pizza" and not pizzaCache[pizza] then
            local distance = (rootPart.Position - pizza.Position).Magnitude
            if distance < closestDistance then
                closestPizza = pizza
                closestDistance = distance
            end
        end
    end
    return closestPizza
end

PZ:AddToggle("AEP", {
    Text = "自动吃披萨",
    Default = false,
    Tooltip = "生命值低于设定值时自动吸引附近披萨",
    Callback = function(enabled)
        _G.AutoEatPizza = enabled
        
        if pizzaConnection then
            pizzaConnection:Disconnect()
            pizzaConnection = nil
        end
        
        if enabled then
            pizzaConnection = RunService.Heartbeat:Connect(function()
                local player = Players.LocalPlayer
                local character = player.Character
                if not character or not character:FindFirstChild("Humanoid") or not character:FindFirstChild("HumanoidRootPart") then
                    return
                end
                
                local humanoid = character.Humanoid
                local rootPart = character.HumanoidRootPart
                
                if _G.HealthEatPizza and humanoid.Health >= _G.HealthEatPizza then
                    return
                end
                
                local closestPizza = findClosestPizza(rootPart)
                if closestPizza then
                    closestPizza.CFrame = closestPizza.CFrame:Lerp(
                        rootPart.CFrame * CFrame.new(0, 0, -2),
                        0.5
                    )
                    createPizzaEffect(closestPizza, "AttractEffect")
                end
                cleanUpEffects()
            end)
        end
    end
})

PZ:AddToggle("ATP", {
    Text = "自动吃披萨",
    Default = false,
    Tooltip = "Automatically transfers the latest pizza to the player when the health value is lower than the set value",
    Callback = function(enabled)
        _G.AutoTeleportPizza = enabled
        
        if pizzaTPConnection then
            pizzaTPConnection:Disconnect()
            pizzaTPConnection = nil
        end
        
        if enabled then
            pizzaTPConnection = RunService.Heartbeat:Connect(function()
                local player = Players.LocalPlayer
                local character = player.Character
                if not character or not character:FindFirstChild("Humanoid") or not character:FindFirstChild("HumanoidRootPart") then
                    return
                end
                
                local humanoid = character.Humanoid
                local rootPart = character.HumanoidRootPart
                
                if _G.HealthEatPizza and humanoid.Health >= _G.HealthEatPizza then
                    return
                end
                
                local closestPizza = findClosestPizza(rootPart)
                if closestPizza then
                    closestPizza.CFrame = rootPart.CFrame * CFrame.new(0, 0, -2)
                    local effect = createPizzaEffect(closestPizza, "TeleportEffect")
                    task.delay(1, function()
                        if effect and effect.Parent then
                            effect:Destroy()
                            pizzaEffects[closestPizza] = nil
                        end
                    end)
                end
                cleanUpEffects()
            end)
        end
    end
})


PZ:AddDivider()  

PZ:AddSlider("HealthThreshold", {
    Text = "生命值阈值",
    Default = 50,
    Min = 10,
    Max = 130,
    Rounding = 0,
    Tooltip = "Health value is below life threshold, eating pizza",
    
    Callback = function(value)
        _G.HealthEatPizza = value
    end
})






PZ:AddDivider()  

PZ:AddButton("InstantAttract", {
    Text = "传送披萨到脚下",
    Func = function()
        local player = Players.LocalPlayer
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character.HumanoidRootPart
            for _, pizza in ipairs(workspace:GetDescendants()) do
                if pizza:IsA("BasePart") and pizza.Name == "Pizza" then
                    pizza.CFrame = rootPart.CFrame
                    break
                end
            end
        end
    end
})




local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Debug")

-- 1. 显示/隐藏快捷键菜单
MenuGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,  -- 默认显示快捷键菜单
    Text = "快捷键菜单",
    Callback = function(value)
        Library.KeybindFrame.Visible = value  -- 控制快捷键菜单的显示/隐藏
    end,
})

-- 2. 自定义鼠标光标
MenuGroup:AddToggle("ShowCustomCursor", {
    Text = "自定义光标",
    Default = true,  -- 默认启用
    Callback = function(Value)
        Library.ShowCustomCursor = Value  -- 启用/禁用自定义光标
    end,
})

-- 3. 设置通知位置（左/右）
MenuGroup:AddDropdown("NotificationSide", {
    Values = { "左侧", "右侧" },
    Default = "右侧",  -- 默认右侧显示通知
    Text = "信息提示位置",
    Callback = function(Value)
        Library:SetNotifySide(Value)  -- 设置通知位置
    end,
})

-- 4. 调整UI缩放比例（DPI）
MenuGroup:AddDropdown("DPIDropdown", {
    Values = { "25%", "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",  -- 默认100%大小
    Text = "界面尺寸",
    Callback = function(Value)
        Value = Value:gsub("%%", "")  -- 移除百分号
        local DPI = tonumber(Value)   -- 转换为数字
        Library:SetDPIScale(DPI)      -- 调整UI缩放
    end,
})


MenuGroup:AddDivider()  
MenuGroup:AddLabel("菜单快捷键")  
    :AddKeyPicker("MenuKeybind", { 
        Default = "RightShift",  
        NoUI = true,            
        Text = "菜单快捷键"    
    })

MenuGroup:AddButton("销毁界面", function()
    Library:Unload()  
end)


ThemeManager:SetLibrary(Library)  
SaveManager:SetLibrary(Library)   
SaveManager:IgnoreThemeSettings() 


SaveManager:SetIgnoreIndexes({ "MenuKeybind" })  
ThemeManager:SetFolder("我的脚本中心")            
SaveManager:SetFolder("我的脚本中心/特定游戏")  
SaveManager:SetSubFolder("特定位置")   
SaveManager:BuildConfigSection(Tabs["UI Settings"])  

ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()

